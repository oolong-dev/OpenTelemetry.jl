var documenterSearchIndex = {"docs":
[{"location":"OpenTelemetrySDK/#OpenTelemetrySDK","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK","text":"","category":"section"},{"location":"OpenTelemetrySDK/#Exporters","page":"OpenTelemetrySDK","title":"Exporters","text":"","category":"section"},{"location":"OpenTelemetrySDK/","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK","text":"Two common exporters are provided to for debugging:","category":"page"},{"location":"OpenTelemetrySDK/","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK","text":"Modules = [OpenTelemetrySDK]\nPages = [\"exporter.jl\"]\nPrivate = false","category":"page"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.AbstractExporter","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.AbstractExporter","text":"An AbstractExporter is to export a collection of AbstractSpans and (or) Metrics. Each method should have the following interfaces implemented:\n\nforce_flush!(::AbstractExporter)\nshut_down!(::AbstractExporter)\nexport!(::AbstractExporter, collection)\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.ConsoleExporter","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.ConsoleExporter","text":"ConsoleExporter(;io=stdout)\n\nPrint an AbstractSpan or Metric into io.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.InMemoryExporter","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.InMemoryExporter","text":"InMemoryExporter(;pool=[], is_shut_down=Ref(false))\n\nSimply store all export!ed elements into the pool.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetrySDK/#Tracer","page":"OpenTelemetrySDK","title":"Tracer","text":"","category":"section"},{"location":"OpenTelemetrySDK/#TracerProvider","page":"OpenTelemetrySDK","title":"TracerProvider","text":"","category":"section"},{"location":"OpenTelemetrySDK/","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK","text":"In SDK, TracerProvider and Span are provided to replace the dummy ones in API. Span is not exported since we mainly use with_span to create new spans.","category":"page"},{"location":"OpenTelemetrySDK/","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK","text":"Modules = [OpenTelemetrySDK]\nPages = [\"trace_provider.jl\"]\nPrivate = false","category":"page"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.TracerProvider","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.TracerProvider","text":"TracerProvider(;kw...)\n\nKeyword Arguments\n\nsampler::AbstractSampler=DEFAULT_ON\nresource=Resource()\nspan_processor::AbstractSpanProcessor=CompositSpanProcessor()\nid_generator::AbstractIdGenerator=RandomIdGenerator()\nlimit_info=LimitInfo()\n\nThe following extra methods are provided beyond those defined in AbstractTracerProvider:\n\nforce_flush!(p::TracerProvider)\nshut_down!(p::TracerProvider)\nBase.push!(p::TracerProvider, sp::AbstractSpanProcessor)\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.force_flush!-Tuple{TracerProvider}","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.force_flush!","text":"force_flush!(p::TracerProvider)\n\nShorthand to force flush inner span processors\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.shut_down!-Tuple{TracerProvider}","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.shut_down!","text":"shut_down!(p::TracerProvider)\n\nShut down inner span processors and then mark itself as shut down.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetrySDK/#ID-Generators","page":"OpenTelemetrySDK","title":"ID Generators","text":"","category":"section"},{"location":"OpenTelemetrySDK/","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK","text":"Modules = [OpenTelemetrySDK]\nPages = [\"id_generator.jl\"]\nPrivate = false","category":"page"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.RandomIdGenerator","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.RandomIdGenerator","text":"RandomIdGenerator(rng=Random.GLOBAL_RNG)\n\nUse the rng to generate a random trace id or span id.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetrySDK/#Samplers","page":"OpenTelemetrySDK","title":"Samplers","text":"","category":"section"},{"location":"OpenTelemetrySDK/","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK","text":"Modules = [OpenTelemetrySDK]\nPages = [\"sampling.jl\"]\nPrivate = false","category":"page"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.ALWAYS_OFF","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.ALWAYS_OFF","text":"Always drop the span.\n\n\n\n\n\n","category":"constant"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.ALWAYS_ON","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.ALWAYS_ON","text":"Always sample the span.\n\n\n\n\n\n","category":"constant"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.DEFAULT_OFF","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.DEFAULT_OFF","text":"Sampler that respects its parent span's sampling decision, but otherwise never samples.\n\n\n\n\n\n","category":"constant"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.DEFAULT_ON","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.DEFAULT_ON","text":"Sampler that respects its parent span's sampling decision, but otherwise always samples.\n\n\n\n\n\n","category":"constant"},{"location":"OpenTelemetrySDK/#Span-Processors","page":"OpenTelemetrySDK","title":"Span Processors","text":"","category":"section"},{"location":"OpenTelemetrySDK/","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK","text":"Modules = [OpenTelemetrySDK]\nPages = [\"span_processor.jl\"]\nPrivate = false","category":"page"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.AbstractSpanProcessor","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.AbstractSpanProcessor","text":"Each span processor must implement the following methods:\n\non_start!(span_processor::AbstractSpanProcessor, span::AbstractSpan)\non_end!(span_processor::AbstractSpanProcessor, span::AbstractSpan)\nshut_down!(span_processor::AbstractSpanProcessor)\nforce_flush!(span_processor::AbstractSpanProcessor)\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.CompositSpanProcessor","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.CompositSpanProcessor","text":"CompositSpanProcessor(processors...)\n\nA wrapper of different concrete span processors. Users can also push! new span processors into it after construction.\n\nSee also SimpleSpanProcessor.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.SimpleSpanProcessor","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.SimpleSpanProcessor","text":"SimpleSpanProcessor(span_exporter)\n\nExport each span immediately when on_end! is called on this processor.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetrySDK/#Metric","page":"OpenTelemetrySDK","title":"Metric","text":"","category":"section"},{"location":"OpenTelemetrySDK/","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK","text":"The current implementation of metrics in SDK is mainly inspired by the dotnet sdk.","category":"page"},{"location":"OpenTelemetrySDK/","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK","text":"┌──────────────────────────────────────────┐\n│MeterProvider                             │\n│                                          │\n│  meters                                  │\n│  views                                   │\n│                                          │\n│  instrument_associated_metric_names      │\n│    instrument =>  Set{metric_name}       │\n│                                          │\n│  metrics                                 │\n│    name => metric                        │\n│    ┌───────────────────────────────────┐ │\n│    │Metric                             │ │\n│    │                                   │ │\n│    │  name                             │ │\n│    │  description                      │ │\n│    │  criteria                         │ │\n│    │  aggregation                      │ │\n│    │    ┌──────────────────────────┐   │ │\n│    │    │AggregationStore          │   │ │\n│    │    │                          │   │ │\n│    │    │  attributes => data_point│   │ │\n│    │    │   ┌─────────────────┐    │   │ │\n│    │    │   │AbstractDataPoint│    │   │ │\n│    │    │   │                 │    │   │ │\n│    │    │   │  value          │    │   │ │\n│    │    │   │  start_time     │    │   │ │\n│    │    │   │  end_time       │    │   │ │\n│    │    │   │  exemplars      │    │   │ │\n│    │    │   │ ┌────────────┐  │    │   │ │\n│    │    │   │ │Exemplar    │  │    │   │ │\n│    │    │   │ │            │  │    │   │ │\n│    │    │   │ │ value      │  │    │   │ │\n│    │    │   │ │ trace_id   │  │    │   │ │\n│    │    │   │ │ span_id    │  │    │   │ │\n│    │    │   │ └────────────┘  │    │   │ │\n│    │    │   │                 │    │   │ │\n│    │    │   └─────────────────┘    │   │ │\n│    │    │                          │   │ │\n│    │    └──────────────────────────┘   │ │\n│    │                                   │ │\n│    └───────────────────────────────────┘ │\n│                                          │\n└──────────────────────────────────────────┘","category":"page"},{"location":"OpenTelemetrySDK/","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK","text":"A View specifies which instruments are grouped together through Criteria. For each view, a Metric is created to store the Measurements. Each metric may have many different dimensions configured by StaticAttrs in a Measurement. For each dimension, we may also collect those Exemplars in the mean while.","category":"page"},{"location":"OpenTelemetrySDK/#Design-decisions","page":"OpenTelemetrySDK","title":"Design decisions","text":"","category":"section"},{"location":"OpenTelemetrySDK/","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK","text":"For each registered instrument, we have stored the associated metrics configured by views into the instrument_associated_metric_names field. So that for each pair of instrument => measurement, we can quickly determine which metrics to update.\nTo make sure that measurements of the same attribute key-values but with different order can be updated in the same dimension in the AggregationStore, a design from opentelemetry-dotnet#2374 is borrowed here.","category":"page"},{"location":"OpenTelemetrySDK/","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK","text":"Modules = [OpenTelemetrySDK]\nPages = [\"aggregation.jl\", \"datapoint_atomic.jl\", \"datapoint_lock.jl\", \"meter_provider.jl\", \"meter_reader.jl\", \"view.jl\"]\nPrivate = false","category":"page"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.DROP","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.DROP","text":"All measurement will be dropped.\n\n\n\n\n\n","category":"constant"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.Exemplar","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.Exemplar","text":"Exemplar(;kw...)\n\nExemplars are example data points for aggregated data. Read the specification to understand its relation to trace and metric.\n\nKeyword arguments:\n\nvalue\ntime_unix_nano\nfiltered_attributes::StaticAttrs, extra attributes of a Measurement that are not included in a Metric's :attribute_keys field.\ntrace_id, the trace_id in the span context when the measurement happens.\nspan_id, the span_id in the span context when the measurement happens.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.HistogramAgg","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.HistogramAgg","text":"HistogramAgg(args...)\n\nArguments:\n\nboundaries::NTuple{M, Float64} where M, the boundaries to calculate histogram buckets. Note that -Inf and Inf shouldn't be included.\nis_record_min\nis_record_max\nagg_store\nexemplar_reservoir_factory, when set to nothing, no exemplar will be stored.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.HistogramAgg-Union{Tuple{}, Tuple{T}} where T","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.HistogramAgg","text":"HistogramAgg{T}(;boundaries = DEFAULT_HISTOGRAM_BOUNDARIES, is_record_min = true, is_record_max = true)\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.LastValueAgg","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.LastValueAgg","text":"LastValueAgg(agg_store::AggregationStore, exemplar_reservoir_factory)\n\nWhen exemplar_reservoir_factory set to nothing, no exemplar will be stored.\n\nSee more details in the specification.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.LastValueAgg-Union{Tuple{}, Tuple{T}} where T","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.LastValueAgg","text":"LastValueAgg{T}()\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.SumAgg","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.SumAgg","text":"SumAgg(agg_store::AggregationStore, exemplar_reservoir_factory)\n\nWhen exemplar_reservoir_factory set to nothing, no exemplar will be stored. See more details in the specification.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.SumAgg-Union{Tuple{}, Tuple{T}} where T","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.SumAgg","text":"SumAgg{T}()\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.MeterProvider-Tuple{}","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.MeterProvider","text":"MeterProvider(;resource = Resource(), views = View[], n_max_metrics = N_MAX_METRICS)\n\nIf views is empty, a default one (View(;instrument_name=\"*\") will be added to enable all metrics.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.View","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.View","text":"View(name=nothing;kwargs...)\n\nThe name support wildcard.\n\nSee more details in the specification.\n\nKeyword arguments\n\ndescription = nothing,\nattribute_keys = nothing,\nextra_dimensions = StaticAttrs(),\naggregation = nothing,\ninstrument_name = nothing,\ninstrument_type = nothing,\nmeter_name = nothing,\nmeter_version = nothing,\nmeter_schema_url = nothing,\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetrySDK/#Misc","page":"OpenTelemetrySDK","title":"Misc","text":"","category":"section"},{"location":"OpenTelemetrySDK/","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK","text":"Modules = [OpenTelemetrySDK]","category":"page"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.AbstractIdGenerator","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.AbstractIdGenerator","text":"Customized id generators must implement the following two methods:\n\ngenerate_span_id(::AbstractIdGenerator)\ngenerate_trace_id(::AbstractIdGenerator)\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.AbstractMetricReader","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.AbstractMetricReader","text":"All metric readers should implement shut_down!(::AbstractMetricReader) and (r::AbstractMetricReader)().\n\nBuiltin readers:\n\nCompositMetricReader\nMetricReader\nPeriodicMetricReader\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.AbstractSampler","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.AbstractSampler","text":"A sampler controls whether to drop a span or not when creating new spans in a certain context. Each sampler should have the should_sample method implemented.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.AggregationStore-Union{Tuple{}, Tuple{D}} where D<:OpenTelemetrySDK.DataPoint","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.AggregationStore","text":"AggregationStore{D}(;kw...) where D<:DataPoint\n\nThe AggregationStore holds all the aggregated datapoints in a Metric.\n\nKeyword arguments\n\nn_max_points = N_MAX_POINTS_PER_METRIC, the maximum number of data points.\nn_max_attrs = 2 * N_MAX_POINTS_PER_METRIC, the maximum number of allowed attributes. Note that each datapoint may have several attributes pointing to them. (Those attributes have the same key-value pair but with different order)\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.MetricReader","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.MetricReader","text":"MetricReader([global_meter_provider()], [ConsoleExporter()])\n\nNote that all metrics will be read on initialization.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.MetricReader-Tuple{}","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.MetricReader","text":"(r::MetricReader)()\n\nFor async instruments in r, their callbacks will be executed first before reading all the metrics.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.PeriodicMetricReader","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.PeriodicMetricReader","text":"PeriodicMetricReader(reader; export_interval_seconds = 60, export_timeout_seconds = 30)\n\nPeriodically call the reader in the background.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.PeriodicMetricReader-Tuple{}","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.PeriodicMetricReader","text":"For PeriodicMetricReader, there's no need to call this method since the read operation will be done periodically in the background.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetrySDK/#Base.push!-Tuple{AbstractSpanProcessor}","page":"OpenTelemetrySDK","title":"Base.push!","text":"Base.push!([p::TracerProvider], sp::AbstractSpanProcessor)\n\nAdd an extra span processor sp into the TracerProvider p.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.on_end!-Tuple{SimpleSpanProcessor, Any}","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.on_end!","text":"on_end!(ssp::SimpleSpanProcessor, span)\n\nThe span is exported immediately if it is sampled.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.on_start!-Tuple{SimpleSpanProcessor, Any}","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.on_start!","text":"on_start!(ssp::SimpleSpanProcessor, span)\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetrySDK/#OpenTelemetrySDK.should_sample","page":"OpenTelemetrySDK","title":"OpenTelemetrySDK.should_sample","text":"should_sample(s::AbstractSampler, args...)\n\nArguments\n\nparent_context::Context,\ntrace_id::TraceIdType,\nname::String, the span name\nkind::SpanKind,\nattributes, StaticAttrs or DynamicAttrs\nlinks, vector of Link\ntrace_state::TraceState,\n\n\n\n\n\n","category":"function"},{"location":"OpenTelemetryInstrumentationDownloads/#OpenTelemetryInstrumentationDownloads","page":"OpenTelemetryInstrumentationDownloads","title":"OpenTelemetryInstrumentationDownloads","text":"","category":"section"},{"location":"OpenTelemetryInstrumentationDownloads/","page":"OpenTelemetryInstrumentationDownloads","title":"OpenTelemetryInstrumentationDownloads","text":"Modules = [OpenTelemetryInstrumentationDownloads]","category":"page"},{"location":"OpenTelemetryInstrumentationDownloads/#OpenTelemetryInstrumentationDownloads.init-Tuple{}","page":"OpenTelemetryInstrumentationDownloads","title":"OpenTelemetryInstrumentationDownloads.init","text":"Schema\n\nMeter Name Instrument Name Instrument Type Unit Description\nDownloads download Counter{UInt}  Number of downloads.\n\n\n\n\n\n","category":"method"},{"location":"tips/#Tips-for-Developers","page":"Tips for Developers","title":"Tips for Developers","text":"","category":"section"},{"location":"tips/#Instrument-a-Package","page":"Tips for Developers","title":"Instrument a Package","text":"","category":"section"},{"location":"tips/","page":"Tips for Developers","title":"Tips for Developers","text":"If you have write permission to the package, you can add the dependency of OpenTelemetryAPI and modify the code as you wish. Otherwise, you need to write an independent instrumentation package. Here are some general conventions.","category":"page"},{"location":"tips/","page":"Tips for Developers","title":"Tips for Developers","text":"Each instrumentation package should implement the init(;tracer_provider=global_tracer_provider(), meter_provider=global_meter_provider()) function. Note that this function shouldn't be exported to avoid confliction. In the module __init__() function, call init() to instrument the target library instantly.\nThe name of Meter should have at least have the module and its parent modules' names as the prefix. Usually people use . to connect different parts.","category":"page"},{"location":"OpenTelemetryProto/#OpenTelemetryProto","page":"OpenTelemetryProto","title":"OpenTelemetryProto","text":"","category":"section"},{"location":"OpenTelemetryProto/","page":"OpenTelemetryProto","title":"OpenTelemetryProto","text":"This package provides the julia client code to the original proto files with gRPCClient.jl and ProtoBuf.jl.","category":"page"},{"location":"OpenTelemetryProto/","page":"OpenTelemetryProto","title":"OpenTelemetryProto","text":"note: Note\nThe major and minor version of OpenTelemetryProto is aligned with the release of original opentelemetry-proto. The patch version is Julia specific.","category":"page"},{"location":"OpenTelemetryProto/","page":"OpenTelemetryProto","title":"OpenTelemetryProto","text":"Modules = [OpenTelemetryProto]\nPrivate = false","category":"page"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI","text":"","category":"section"},{"location":"OpenTelemetryAPI/","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI","text":"The content in this page is organized in the same order as the OpenTelemetry Specification.","category":"page"},{"location":"OpenTelemetryAPI/#Context","page":"OpenTelemetryAPI","title":"Context","text":"","category":"section"},{"location":"OpenTelemetryAPI/","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI","text":"All the MUST items in the original specification are implemented.","category":"page"},{"location":"OpenTelemetryAPI/","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI","text":"Context is implemented as a wrapper of NamedTuple, which means it is immutable. Each Task has exactly ONE Context instance, which is injected into the task_local_storage of the current_task by the parent task automatically.","category":"page"},{"location":"OpenTelemetryAPI/","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI","text":"warning: Warning\nType piracy is used to the propagate context between tasks. See more discussions in #32","category":"page"},{"location":"OpenTelemetryAPI/","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI","text":"create_key is used to create a context key. But it is not exported yet because it seems to be only used internally until now.","category":"page"},{"location":"OpenTelemetryAPI/","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI","text":"Base.getindex(::Context, key) is implemented so to get a value in a Context, one can simply call ctx[key] to get the associated value of a key in a ctx.","category":"page"},{"location":"OpenTelemetryAPI/","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI","text":"Setting value of a Context is not directly supported. Given that Context is immutable, updating an immutable object in Julia seems strange. We provide the with_context function to create a new context based on the key-value pairs in the current_context. This syntax is more common than the attach/detach operations in the original specification.","category":"page"},{"location":"OpenTelemetryAPI/","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI","text":"Modules = [OpenTelemetryAPI]\nPages = [\"context.jl\"]\nPrivate = false","category":"page"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.current_context-Tuple{}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.current_context","text":"Return the Context associated with the caller's current execution unit.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.with_context-Tuple{Any, OpenTelemetryAPI.Context}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.with_context","text":"with_context(f, [context]; kv...)\n\nRun function f in the context. If extra kv pairs are provided, they will be merged with the context to form a new context. When context is not provided, the current_context will be used.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#Propagators","page":"OpenTelemetryAPI","title":"Propagators","text":"","category":"section"},{"location":"OpenTelemetryAPI/","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI","text":"inject! and extract are provided based on the original specification. However, TextMapPropagator is not implemented yet! Personally I feel that every propagator may depends on a third party package. To minimize the dependencies of OpenTelemetryAPI.jl, those specialized propagators can be registered as independent packages.","category":"page"},{"location":"OpenTelemetryAPI/","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI","text":"The GLOBAL_PROPAGATOR is set to a CompositePropagator, with multiple dispatch, each inner propagator can be customized to handle different contexts and carriers. Since it's mainly used internally for now, it's not exposed yet.","category":"page"},{"location":"OpenTelemetryAPI/","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI","text":"Modules = [OpenTelemetryAPI]\nPages = [\"propagator.jl\"]\nPrivate = false","category":"page"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.extract","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.extract","text":"extract(carrier, [global_propagator], [current_context])\n\nExtracts the value from an incoming request. For example, from the headers of an HTTP request.\n\n\n\n\n\n","category":"function"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.inject!","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.inject!","text":"inject(carrier, [global_propagator], [current_context])\n\nInjects the value into a carrier. For example, into the headers of an HTTP request.\n\n\n\n\n\n","category":"function"},{"location":"OpenTelemetryAPI/#Trace","page":"OpenTelemetryAPI","title":"Trace","text":"","category":"section"},{"location":"OpenTelemetryAPI/","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI","text":"The relationship between trace provider, tracer, span context and span is depicted below:","category":"page"},{"location":"OpenTelemetryAPI/","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI","text":"┌────────────────────────────┐\n│ AbstractSpan               │\n│   ┌──────────────────────┐ │\n│   │ Tracer               │ │\n│   │   ┌────────────────┐ │ │\n│   │   │    Abstract    │ │ │\n│   │   │ TracerProvider │ │ │\n│   │   └────────────────┘ │ │\n│   │  instrumentation     │ │\n│   │   ┌────────────────┐ │ │\n│   │   │ name           │ │ │\n│   │   │ version        │ │ │\n│   │   └────────────────┘ │ │\n│   └──────────────────────┘ │\n└────────────────────────────┘","category":"page"},{"location":"OpenTelemetryAPI/","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI","text":"In OpenTelemetryAPI.jl, only one concrete AbstractTracerProvider (the DummyTracerProvider) is provided. It is set as the  default global_tracer_provider. Without SDK installed, the with_span will only create a NonRecordingSpan. This is to make the OpenTelemetryAPI.jl lightweight enough so that instrumentation package users can happily add it as a dependency without losing performance.","category":"page"},{"location":"OpenTelemetryAPI/","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI","text":"Modules = [OpenTelemetryAPI]\nPages = [\"tracer_provider.jl\"]\nPrivate = false","category":"page"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.AbstractSpan","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.AbstractSpan","text":"Each concrete span should have the following interfaces implemented.\n\ntracer\nspan_context\nspan_kind\nparent_span_context\nattributes\nis_recording\nstart_time\nend_time\nend_span!\nspan_status!\nspan_status\nspan_name!\nspan_name\nspan_links\nspan_events\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.AbstractTracerProvider","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.AbstractTracerProvider","text":"A tracer provider is a part of an Tracer. For each concrete tracer provider, resource and OpenTelemetryAPI.create_span(name::String, tracer::Tracer{<:YourCustomProvider}) should also be implemented.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.Tracer","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.Tracer","text":"Tracer(name=\"Main\", version=v\"0.0.1-dev\";provider=global_tracer_provider())\n\nThe name and version will form the InstrumentationInfo. value.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.end_span!-Tuple{}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.end_span!","text":"end_span!([s=current_span()], [t=UInt(time()*10^9)])\n\nSet the end time of the span and trigger span processors. Note t is the nanoseconds.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.global_tracer_provider!-Tuple{Any}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.global_tracer_provider!","text":"global_tracer_provider!(p)\n\nSet the global tracer provider to p.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.global_tracer_provider-Tuple{}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.global_tracer_provider","text":"global_tracer_provider()\n\nGet the global tracer provider.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.is_recording-Tuple{}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.is_recording","text":"is_recording([current_span()])\n\nReturns true if this span s is recording information like Event operations, attribute modification using setindex!, etc.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.parent_span_context-Tuple{}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.parent_span_context","text":"parent_span_context(s::AbstractSpan)\n\nGet the SpanContext from parent span.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.provider-Tuple{AbstractSpan}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.provider","text":"provider(s::AbstractSpan)\n\nGet the AbstractTracerProvider which generates the tracer that the span s resides in.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.resource-Tuple{AbstractSpan}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.resource","text":"resource(s::AbstractSpan)\n\nGet the associated resource of the span s. Fall back to resource(provider(::AbstractSpan))\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.span_context-Tuple{}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.span_context","text":"span_context([s::AbstractSpan])\n\nGet the SpanContext from a span s. If s is not specified, current_span() will be used. nothing is returned if no span context found.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.span_events-Tuple{}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.span_events","text":"span_events(s::AbstractSpan)\n\nGet the recorded events in a span. A Limited is expected.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.span_kind-Tuple{}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.span_kind","text":"span_kind([current_span()])\n\nReturn SpanKind\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.span_links-Tuple{}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.span_links","text":"span_links(s::AbstractSpan)\n\nGet the recorded links in a span. A Limited is expected.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.span_name!-Tuple{String}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.span_name!","text":"span_name!([current_span()], name::String)\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.span_name-Tuple{}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.span_name","text":"span_name([current_span()])\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.span_status!-Tuple{SpanStatusCode, Any}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.span_status!","text":"span_status!([current_span()], code::SpanStatusCode, description=nothing)\n\nUpdate the status of span s by following the original specification. description is only considered when the code is SPAN_STATUS_ERROR. Only valid when the span is not ended yet.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.span_status-Tuple{}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.span_status","text":"span_status([current_span()])\n\nGet status of the span. A SpanStatusCode is returned.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.tracer-Tuple{OpenTelemetryAPI.NonRecordingSpan}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.tracer","text":"tracer(s::AbstractSpan)\n\nGet the Tracer which generates the span s.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.with_span","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.with_span","text":"with_span(f, name::String, [tracer=Tracer()];kw...)\n\nCall function f with the current span set a newly created one of name with tracer.\n\nKeyword arguments\n\nend_on_exit=true, controls whether to call end_span! after f or not.\nrecord_exception=true, controls whether to record the exception.\nset_status_on_exception=true, decides whether to set status to SPAN_STATUS_ERROR automatically when an exception is caught.\nThe rest keyword arguments are forwarded to create_span.\n\n\n\n\n\n","category":"function"},{"location":"OpenTelemetryAPI/#Metric","page":"OpenTelemetryAPI","title":"Metric","text":"","category":"section"},{"location":"OpenTelemetryAPI/","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI","text":"The relationship between MeterProvider, Meter and different instruments are depicted below:","category":"page"},{"location":"OpenTelemetryAPI/","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI","text":" ┌─────────────────────────────┐\n │AbstractInstrument           │\n │                             │\n │  name                       │\n │  unit                       │\n │  description                │\n │                             │\n │  meter                      │\n │   ┌───────────────────────┐ │\n │   │Meter                  │ │\n │   │                       │ │\n │   │  provider             │ │\n │   │   ┌────────────────┐  │ │\n │   │   │   Abstract     │  │ │\n │   │   │ MeterProvider  │  │ │\n │   │   └────────────────┘  │ │\n │   │  name                 │ │\n │   │  version              │ │\n │   │  schema_url           │ │\n │   │                       │ │\n │   │  instrumentation      │ │\n │   │   ┌────────────────┐  │ │\n │   │   │ name           │  │ │\n │   │   │ version        │  │ │\n │   │   └────────────────┘  │ │\n │   │  instruments          │ │\n │   │                       │ │\n │   │    * Counter          │ │\n │   │    * Histogram        │ │\n │   │    * UpDownCounter    │ │\n │   │    * ObservableCounter│ │\n │   │    * Observable       │ │\n │   │      UpDownCounter    │ │\n │   └───────────────────────┘ │\n │                             │\n └─────────────────────────────┘","category":"page"},{"location":"OpenTelemetryAPI/","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI","text":"An Instrument belongs to a Meter, each Meter may contain many different Instruments. Similarly, a Meter belongs to a MeterProvider and a MeterProvider may contain many different Meters.","category":"page"},{"location":"OpenTelemetryAPI/","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI","text":"Modules = [OpenTelemetryAPI]\nPages = [\"metric_provider.jl\"]\nPrivate = false","category":"page"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.AbstractInstrument","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.AbstractInstrument","text":"AbstractInstrumentis the super type of all instruments, which are used to report [Measurement`](@ref)s.\n\nSee also the specification:\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.AbstractMeterProvider","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.AbstractMeterProvider","text":"A meter provider defines how to collect and update Measurements. Each meter provider should have the following interfaces implemented:\n\nBase.push!(provider, m::Meter), register a meter.\nBase.push!(provider, ins::AbstractInstrument), register an instrument.\nBase.push!(provider, (ins::AbstractInstrument, m::Measurement)), update a measurement.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.Meter","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.Meter","text":"Meter(name::String;kw...)\n\nMeter is responsible for creating instruments.\n\nKeyword Arguments:\n\nprovider::P = global_meter_provider()\nversion = v\"0.0.1-dev\"\nschema_url = \"\"\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.global_meter_provider!-Tuple{Any}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.global_meter_provider!","text":"global_meter_provider!(p)\n\nSet the global meter provider to p.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.global_meter_provider-Tuple{}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.global_meter_provider","text":"global_meter_provider()\n\nGet the global meter provider.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#Instruments","page":"OpenTelemetryAPI","title":"Instruments","text":"","category":"section"},{"location":"OpenTelemetryAPI/","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI","text":"All instruments provided here can be classified into two categories: AbstractSyncInstrument and AbstractAsyncInstrument.","category":"page"},{"location":"OpenTelemetryAPI/","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI","text":"Modules = [OpenTelemetryAPI]\nPages = [\"instruments.jl\"]\nPrivate = false","category":"page"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.AbstractAsyncInstrument","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.AbstractAsyncInstrument","text":"Async instrument usually has a callback function (which is named Observable in OpenTelemetry) to get its measurement.\n\nnote: Note\nIf the return of the callback function is not a Measurement, it will be converted into a Measurement with an empty StaticAttrs implicitly when being uploaded to the associated meter provider.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.AbstractSyncInstrument","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.AbstractSyncInstrument","text":"Sync instrument usually pass its measurement immediately.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.Counter","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.Counter","text":"Counter{T}(name, meter;unit=\"\", description=\"\") where T\n\nCounter is a AbstractSyncInstrument which supports non-negative increments.\n\nSee more details from the specification.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.Histogram","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.Histogram","text":"Histogram{T}(name, meter; unit = \"\", description = \"\") where {T}\n\nHistogramisAbstractSyncInstrument` which can be used to report arbitrary values that are likely to be statistically meaningful. It is intended for statistics such as histograms, summaries, and percentile.\n\nSee more details from the specification\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.Measurement","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.Measurement","text":"Measurement(value, [attributes=StaticAttrs()])\n\nThis is to follow the specification\n\nSee also StaticAttrs\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.ObservableCounter","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.ObservableCounter","text":"ObservableCounter{T}(callback, name, meter; unit = \"\", description = \"\") where {T}\n\nObservableCounter is an AbstractAsyncInstrument which reports monotonically increasing value(s) when the instrument is being observed.\n\nSee more details from the specification\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.ObservableGauge","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.ObservableGauge","text":"ObservableGauge{T}(callback, name, meter; unit = \"\", description = \"\",) where {T}\n\nObservableGauge is an AbstractAsyncInstrument which reports non-additive value(s) (e.g. the room temperature - it makes no sense to report the temperature value from multiple rooms and sum them up) when the instrument is being observed.\n\nSee also the details from the specification\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.ObservableUpDownCounter","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.ObservableUpDownCounter","text":"ObservableUpDownCounter{T}(callback, name, meter; unit = \"\", description = \"\") where {T}\n\nObservableUpDownCounter is an AbstractAsyncInstrument which reports additive value(s) (e.g. the process heap size - it makes sense to report the heap size from multiple processes and sum them up, so we get the total heap usage) when the instrument is being observed.\n\nSee more details from the specification.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.UpDownCounter","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.UpDownCounter","text":"UpDownCounter{T}(name, meter; unit = \"\", description = \"\") where {T}\n\nUpDownCounter is a AbstractSyncInstrument which supports increments and decrements.\n\nSee also the details from the specification.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#Logging","page":"OpenTelemetryAPI","title":"Logging","text":"","category":"section"},{"location":"OpenTelemetryAPI/","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI","text":"The idea is simple, a OtelLogTransformer is provided to transform each logging message into a LogRecord. To understand how to use it, users should be familiar with how TransformerLogger from LoggingExtras.jl works.","category":"page"},{"location":"OpenTelemetryAPI/","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI","text":"Modules = [OpenTelemetryAPI]\nPages = [\"log.jl\"]\nPrivate = false","category":"page"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.LogRecord","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.LogRecord","text":"LogRecord(;kw...)\n\nA Julia representation of the Log Data Model.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.OtelLogTransformer","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.OtelLogTransformer","text":"OtelLogTransformer(resource::Resource)\n\nIt can be used as a function f to the TransformerLogger. After applying this transformer, a LogRecord will be returned.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#Misc","page":"OpenTelemetryAPI","title":"Misc","text":"","category":"section"},{"location":"OpenTelemetryAPI/","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI","text":"Modules = [OpenTelemetryAPI]","category":"page"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.TAttrVal","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.TAttrVal","text":"Valid type of attribute value.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.CompositePropagator","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.CompositePropagator","text":"CompositePropagator(propagators::Vector)\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.DynamicAttrs","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.DynamicAttrs","text":"DynamicAttrs(attrs::Dict{String, TAttrVal};count_limit=128, value_length_limit=nothing)\nDynamicAttrs(attrs::Pair{String, TAttrVal}...;count_limit=128, value_length_limit=nothing)\n\nHere we use a Dict internally to represent the mutable version of the Attributes specification. If the value_length_limit is set to a positive int, the value of String or each element in a value of Vector{String} will be truncated to a maximum length of value_length_limit. By default we do not do the truncation. When adding new pairs into it, if the number of attributes exceeds the count_limit, it will be dropped. You can get the number of dropped pairs via n_dropped.\n\nSee also StaticAttrs.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.Event","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.Event","text":"Event(name, timestamp=time()*10^9, attributes=StaticAttrs())\n\ntimestamp is the nanoseconds.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.InstrumentationInfo","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.InstrumentationInfo","text":"InstrumentationInfo(;name=\"Main\", version=v\"0.0.1-dev\")\n\nUsually used in an instrumentation package.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.LimitInfo","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.LimitInfo","text":"LimitInfo(;kw...)\n\nUsed in TracerProvider to configure generated Tracer.\n\nKeyword arguments:\n\nspan_attribute_count_limit::Int = 128\nspan_attribute_value_length_limit::Union{Nothing,Int} = nothing\nspan_event_count_limit::Int = 128\nspan_link_count_limit::Int = 128\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.Limited","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.Limited","text":"Limited(container; limit=32)\n\nCreate a container wrapper with limited elements. It supports the following common containers:\n\nAbstractDict. If the length of the dict contains more elements than limit. Then pop! will be called repeatedly until the length is equal to limit. Further new key-value pair insertions will be ignored. If the key already exists in the dict, then the corresponding value will always be updated. n_dropped will return the number of dropped insertions.\nAbstractVector. Similar to AbstractDict.\n\nThe following methods from Base are defined on Limited which are then forwarded to the inner container. Feel free to create a PR if you find any method you need is missing:\n\nBase.getindex\nBase.setindex!\nBase.iterate\nBase.length\nBase.haskey\nBase.push!. Only defined on containers of AbstractVector.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.Link","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.Link","text":"Link(span_context, attributes)\n\nSee more details at links between spans.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.Resource","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.Resource","text":"Resource(;attributes=StaticAttrs(), schema_url=\"\")\n\nQuoted from the specification:\n\nResource captures information about the entity for which telemetry is recorded. For example, metrics exposed by a Kubernetes container can be linked to a resource that specifies the cluster, namespace, pod, and container name.Resource may capture an entire hierarchy of entity identification. It may describe the host in the cloud and specific container or an application running in the process.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.SpanContext","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.SpanContext","text":"SpanContext(;span_id, trace_id, is_remote, trace_flag=TraceFlag(), trace_state=TraceState())\n\nA SpanContext represents the portion of a Span which must be serialized and propagated along side of a distributed context. SpanContexts are immutable.\n\nThe OpenTelemetry SpanContext representation conforms to the W3C TraceContext specification. It contains two identifiers - a TraceId and a SpanId - along with a set of common TraceFlags and system-specific TraceState values.\n\nTraceId A valid trace identifier is a 16-byte array with at least one non-zero byte.\n\nSpanId A valid span identifier is an 8-byte array with at least one non-zero byte.\n\nTraceFlags contain details about the trace. Unlike TraceState values, TraceFlags are present in all traces. The current version of the specification only supports a single flag called sampled.\n\nTraceState carries vendor-specific trace identification data, represented as a list of key-value pairs. TraceState allows multiple tracing systems to participate in the same trace. It is fully described in the W3C Trace Context specification.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.SpanStatus","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.SpanStatus","text":"SpanStatus(code, description=nothing)\n\nPossible codes are:\n\nSPAN_STATUS_UNSET\nSPAN_STATUS_ERROR\nSPAN_STATUS_OK\n\ndescription is required when code is SPAN_STATUS_ERROR.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.StaticAttrs","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.StaticAttrs","text":"StaticAttrs(attrs::NamedTuple; value_length_limit=nothing)\nStaticAttrs(attrs::Pair{String, TAttrVal}...; value_length_limit=nothing)\nStaticAttrs(attrs::Pair{Symbol, TAttrVal}...; value_length_limit=nothing)\n\nHere we use the NamedTuple internally to efficiently represent the immutable version of the Attributes in the specification. If the value_length_limit is set to a positive int, the value of String or each element in a value of Vector{String} will be truncated to a maximum length of it. By default we do not do the truncation.\n\nSee also DynamicAttrs.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.TraceState","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.TraceState","text":"TraceState(entries::Pair{String,String}...)\n\nTraceState carries vendor-specific trace identification data, represented as a list of key-value pairs. TraceState allows multiple tracing systems to participate in the same trace. It is fully described in the W3C Trace Context specification.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryAPI/#Base.getindex-Tuple{AbstractSpan, Any}","page":"OpenTelemetryAPI","title":"Base.getindex","text":"Base.getindex(s::AbstractSpan, key)\n\nLook up key in the attributes of the span s.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#Base.haskey-Tuple{AbstractSpan, Any}","page":"OpenTelemetryAPI","title":"Base.haskey","text":"Base.haskey(s::AbstractSpan, key)\n\nCheck if the span s has the key in its attributes.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#Base.push!-Tuple{Event}","page":"OpenTelemetryAPI","title":"Base.push!","text":"Base.push!([s::AbstractSpan], event::Event)\n\nAdd an Event into the span s.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#Base.push!-Tuple{Link}","page":"OpenTelemetryAPI","title":"Base.push!","text":"Base.push!([current_span()], link::Link)\n\nAdd a Link into the span s.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#Base.push!-Tuple{OpenTelemetryAPI.NonRecordingSpan, Exception}","page":"OpenTelemetryAPI","title":"Base.push!","text":"Base.push!(s::AbstractSpan, ex::Exception; is_rethrow_followed = false)\n\nA specialized variant of Event to record exceptions. Usually used in a try... catch...end to capture the backtrace. If the ex is rethrowed in the catch...end, is_rethrow_followed should be set to true.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#Base.setindex!-Tuple{AbstractSpan, Any, Any}","page":"OpenTelemetryAPI","title":"Base.setindex!","text":"(s::AbstractSpan)[key] = val\n\nSet the attributes in span s. Only valid when the span is not ended yet.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.attributes-Tuple{OpenTelemetryAPI.NonRecordingSpan}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.attributes","text":"attributes(s::AbstractSpan)\n\nReturn either StaticAttrs or DynamicAttrs in the span s.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.create_span-Tuple{String, Tracer{OpenTelemetryAPI.DummyTracerProvider}}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.create_span","text":"Here we follow the Behavior of the API in the absence of an installed SDK.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.current_span-Tuple{}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.current_span","text":"current_span([current_context])\n\nGet the span in the current context.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.end_time-Tuple{OpenTelemetryAPI.NonRecordingSpan}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.end_time","text":"end_time(s::AbstractSpan)\n\nGet the end time of span s in nanoseconds.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.n_dropped-Tuple{Limited}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.n_dropped","text":"n_dropped(x::Limited)\n\nReturn the total number of dropped elements since creation.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryAPI/#OpenTelemetryAPI.start_time-Tuple{OpenTelemetryAPI.NonRecordingSpan}","page":"OpenTelemetryAPI","title":"OpenTelemetryAPI.start_time","text":"start_time(s::AbstractSpan)\n\nGet the start time of span s in nanoseconds.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryExporterOtlpProtoGrpc/#OpenTelemetryExporterOtlpProtoGrpc","page":"OpenTelemetryExporterOtlpProtoGrpc","title":"OpenTelemetryExporterOtlpProtoGrpc","text":"","category":"section"},{"location":"OpenTelemetryExporterOtlpProtoGrpc/","page":"OpenTelemetryExporterOtlpProtoGrpc","title":"OpenTelemetryExporterOtlpProtoGrpc","text":"This package uses OpenTelemetryProto to communicate with OTEL Collector through gRPC.","category":"page"},{"location":"OpenTelemetryExporterOtlpProtoGrpc/","page":"OpenTelemetryExporterOtlpProtoGrpc","title":"OpenTelemetryExporterOtlpProtoGrpc","text":"Modules = [OpenTelemetryExporterOtlpProtoGrpc]\nPrivate = false","category":"page"},{"location":"OpenTelemetryExporterOtlpProtoGrpc/#OpenTelemetryExporterOtlpProtoGrpc.OtlpProtoGrpcTraceExporter-Tuple{}","page":"OpenTelemetryExporterOtlpProtoGrpc","title":"OpenTelemetryExporterOtlpProtoGrpc.OtlpProtoGrpcTraceExporter","text":"OtlpProtoGrpcTraceExporter(;kw...)\n\nKeyword arguments\n\nscheme=http\nhost=\"localhost\"\nport=4317\nis_blocking=true, by default the BlockingClient is used.\nRest keyword arguments will be forward to the gRPC client.\n\nscheme, host and port specifies the OTEL Collector to connect with.\n\n\n\n\n\n","category":"method"},{"location":"OpenTelemetryExporterPrometheus/#OpenTelemetryExporterPrometheus","page":"OpenTelemetryExporterPrometheus","title":"OpenTelemetryExporterPrometheus","text":"","category":"section"},{"location":"OpenTelemetryExporterPrometheus/","page":"OpenTelemetryExporterPrometheus","title":"OpenTelemetryExporterPrometheus","text":"In this package, only one AbstractExporter is exported: the PrometheusExporter. With this exporter, one can use the Prometheus to view the Metrics.","category":"page"},{"location":"OpenTelemetryExporterPrometheus/","page":"OpenTelemetryExporterPrometheus","title":"OpenTelemetryExporterPrometheus","text":"Modules = [OpenTelemetryExporterPrometheus]\nPrivate = false","category":"page"},{"location":"OpenTelemetryExporterPrometheus/#OpenTelemetryExporterPrometheus.PrometheusExporter","page":"OpenTelemetryExporterPrometheus","title":"OpenTelemetryExporterPrometheus.PrometheusExporter","text":"PrometheusExporter(; host = \"127.0.0.1\", port = 9966, kw...)\n\nIt will setup a http server configured by host and port on initialization. Here the extra keyword arguments kw will be forwarded to HTTP.listen.\n\nUsage\n\nr = MetricReader(PrometheusExporter())\n\nNote that since PrometheusExporter is pull based exporter, which means there's no need to execute r() to update the metrics.\n\n\n\n\n\n","category":"type"},{"location":"OpenTelemetryInstrumentationBase/#OpenTelemetryInstrumentationBase","page":"OpenTelemetryInstrumentationBase","title":"OpenTelemetryInstrumentationBase","text":"","category":"section"},{"location":"OpenTelemetryInstrumentationBase/","page":"OpenTelemetryInstrumentationBase","title":"OpenTelemetryInstrumentationBase","text":"Modules = [OpenTelemetryInstrumentationBase]","category":"page"},{"location":"OpenTelemetryInstrumentationBase/#OpenTelemetryInstrumentationBase.init-Tuple{}","page":"OpenTelemetryInstrumentationBase","title":"OpenTelemetryInstrumentationBase.init","text":"Schema\n\nMeter Name Instrument Name Instrument Type Unit Description\nBase.Sys uptime ObservableGauge second The current system uptime in seconds.\nBase.Sys free_memory ObservableGauge bytes The total free memory in RAM in bytes.\nBase.Sys free_memory_ratio ObservableGauge % The ratio of free memory in percentage.\nBase.Sys maxrss ObservableGauge bytes The maximum resident set size utilized in bytes.The current system uptime in seconds.\nBase jit_total_bytes ObservableGauge bytes The total amount (in bytes) allocated by the just-in-time compiler.\nBase gc_live_bytes ObservableGauge bytes The total size of live objects after the last garbage collection, plus the number of bytes allocated since then.\nBase gc_time_ns ObservableGauge nanoseconds Total time spend in garbage collection, in nanoseconds\n\n\n\n\n\n","category":"method"},{"location":"#OpenTelemetry.jl","page":"Home","title":"OpenTelemetry.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: doc) (Image: CI) (Image: codecov) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages)","category":"page"},{"location":"","page":"Home","title":"Home","text":"An unofficial implementation of OpenTelemetry in Julia.","category":"page"},{"location":"#Packages","page":"Home","title":"Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Package Description Latest Version\nOpenTelemetryAPI Common data structures and interfaces. Instrumentations should rely on it only. (Image: version)\nOpenTelemetrySDK Based on the specification, application owners use SDK constructors; plugin authors use SDK plugin interfaces (Image: version)\nOpenTelemetryProto See the OTLP specification (Image: version)\nOpenTelemetryExporterOtlpProtoGrpc Provide an AbstractExporter in OTLP through gRPC (Image: version)\nOpenTelemetryExporterPrometheus Provide an AbstractExporter to allow pulling metrics from Prometheus (Image: version)\nOpenTelemetry Reexport all above. For demonstration and test only. Application users should import OpenTelemetrySDK and necessary plugins or instrumentations explicitly. (Image: version)\nOpenTelemetryInstrumentationBase Add basic metrics under the Base module in Julia runtime. \nOpenTelemetryUber Reexport all above. For demonstration and test only. Application users should import OpenTelemetrySDK and necessary plugins or instrumentations explicitly. ","category":"page"},{"location":"#Get-Started","page":"Home","title":"Get Started","text":"","category":"section"},{"location":"#Traces","page":"Home","title":"Traces","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To show traces in your console:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using OpenTelemetry\n\nwith_span(\"Hello\") do\n    with_span(\"World\") do\n        println(\"Hello world from OpenTelemetry.jl!\")\n    end\nend","category":"page"},{"location":"#Metrics","page":"Home","title":"Metrics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using OpenTelemetry\n\nm = Meter(\"demo_metrics\");\nc = Counter{Int}(\"fruit_counter\", m);\n\nc(; name = \"apple\", color = \"red\")\nc(2; name = \"lemon\", color = \"yellow\")\nc(1; name = \"lemon\", color = \"yellow\")\nc(2; name = \"apple\", color = \"green\")\nc(5; name = \"apple\", color = \"red\")\nc(4; name = \"lemon\", color = \"yellow\")\n\nr = MetricReader();\nr()\n","category":"page"},{"location":"#Logging","page":"Home","title":"Logging","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using OpenTelemetry\nusing Logging\nusing LoggingExtras\n\nwith_span(\"Hello\") do\n    with_logger(TransformerLogger(OtelLogTransformer(), global_logger())) do\n        @info \"World!\"\n    end\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more details, please read the tutorial.","category":"page"},{"location":"#Benchmarks","page":"Home","title":"Benchmarks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Check out the benchmark results with Julia@v1.6, Julia@v1.7.","category":"page"}]
}
