var documenterSearchIndex = {"docs":
[{"location":"design_sdk/#SDK","page":"SDK","title":"SDK","text":"","category":"section"},{"location":"design_sdk/","page":"SDK","title":"SDK","text":"Two common exporters are provided to for debugging:","category":"page"},{"location":"design_sdk/","page":"SDK","title":"SDK","text":"InMemoryExporter\nConsoleExporter","category":"page"},{"location":"design_sdk/#Trace","page":"SDK","title":"Trace","text":"","category":"section"},{"location":"design_sdk/","page":"SDK","title":"SDK","text":"In SDK, a dedicated TraceProvider is provided.","category":"page"},{"location":"design_sdk/","page":"SDK","title":"SDK","text":"TraceProvider\nCompositSpanProcessor\nALWAYS_ON\nALWAYS_OFF\nDEFAULT_ON\nDEFAULT_OFF\nTraceIdRatioBased","category":"page"},{"location":"design_sdk/#Metric","page":"SDK","title":"Metric","text":"","category":"section"},{"location":"design_sdk/","page":"SDK","title":"SDK","text":"The current implementation of metrics in SDK is mainly inspired by the dotnet sdk.","category":"page"},{"location":"design_sdk/","page":"SDK","title":"SDK","text":"┌──────────────────────────────────────────┐\n│MeterProvider                             │\n│                                          │\n│  meters                                  │\n│  views                                   │\n│                                          │\n│  instrument_associated_metric_names      │\n│    instrument =>  Set{metric_name}       │\n│                                          │\n│  metrics                                 │\n│    name => metric                        │\n│    ┌───────────────────────────────────┐ │\n│    │Metric                             │ │\n│    │                                   │ │\n│    │  name                             │ │\n│    │  description                      │ │\n│    │  criteria                         │ │\n│    │  aggregation                      │ │\n│    │    ┌──────────────────────────┐   │ │\n│    │    │AggregationStore          │   │ │\n│    │    │                          │   │ │\n│    │    │  attributes => data_point│   │ │\n│    │    │   ┌─────────────────┐    │   │ │\n│    │    │   │AbstractDataPoint│    │   │ │\n│    │    │   │                 │    │   │ │\n│    │    │   │  value          │    │   │ │\n│    │    │   │  start_time     │    │   │ │\n│    │    │   │  end_time       │    │   │ │\n│    │    │   │  exemplars      │    │   │ │\n│    │    │   │ ┌────────────┐  │    │   │ │\n│    │    │   │ │Exemplar    │  │    │   │ │\n│    │    │   │ │            │  │    │   │ │\n│    │    │   │ │ value      │  │    │   │ │\n│    │    │   │ │ trace_id   │  │    │   │ │\n│    │    │   │ │ span_id    │  │    │   │ │\n│    │    │   │ └────────────┘  │    │   │ │\n│    │    │   │                 │    │   │ │\n│    │    │   └─────────────────┘    │   │ │\n│    │    │                          │   │ │\n│    │    └──────────────────────────┘   │ │\n│    │                                   │ │\n│    └───────────────────────────────────┘ │\n│                                          │\n└──────────────────────────────────────────┘","category":"page"},{"location":"design_sdk/","page":"SDK","title":"SDK","text":"A View specifies which instruments are grouped together through Criteria. For each view, a Metric is created to store the Measurements. Each metric may have many different dimensions configured by StaticAttrs in a Measurement. For each dimension, we may also collect those [Exemplar]s in the mean while.","category":"page"},{"location":"design_sdk/#Design-decisions","page":"SDK","title":"Design decisions","text":"","category":"section"},{"location":"design_sdk/","page":"SDK","title":"SDK","text":"For each registered instrument, we have stored the associated metrics configured by views into the instrument_associated_metric_names field. So that for each pair of instrument => measurement, we can quickly determine which metrics to update.\nThe make sure that measurements with the same attribute key-values but with different order can be updated in the same dimension in the AggregationStore, a design from opentelemetry-dotnet#2374 is borrowed here.","category":"page"},{"location":"design_sdk/","page":"SDK","title":"SDK","text":"MeterProvider\nView\nMetric\nAggregationStore","category":"page"},{"location":"design/#Design","page":"Design","title":"Design","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"The content in this page is organized in the same order as the OpenTelemetry Specification.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"using OpenTelemetryAPI","category":"page"},{"location":"design/#API","page":"Design","title":"API","text":"","category":"section"},{"location":"design/#Context","page":"Design","title":"Context","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Context is implemented as a wrapper of NamedTuple, which means it is immutable. Each Task has exactly ONE Context instance, which is injected into the task_local_storage of the current_task by the parent task automatically.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"warning: Warning\nType piracy is used to the propagate context between tasks.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"create_key is used to create a context key. But it is not exported yet because it seems to be only used internally until now.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Base.getindex(::Context, key) is implemented so to get a value in a Context, one can simply call ctx[key] to get the associated value of a key in a ctx.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"Setting value of a Context is not directly supported. Given that Context is immutable, updating an immutable object in Julia seems strange. We provide the with_context function to create a new context based on the key-value pairs in the current_context. This syntax is more common than the attach/detach operations in the original specification.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"with_context\ncurrent_context","category":"page"},{"location":"design/#OpenTelemetryAPI.with_context","page":"Design","title":"OpenTelemetryAPI.with_context","text":"with_context(f, [context]; kv...)\n\nRun function f in the context. If extra kv pairs are provided, they will be merged with the context to form a new context. When context is not provided, the current_context will be used.\n\n\n\n\n\n","category":"function"},{"location":"design/#OpenTelemetryAPI.current_context","page":"Design","title":"OpenTelemetryAPI.current_context","text":"Return the Context associated with the caller's current execution unit.\n\n\n\n\n\n","category":"function"},{"location":"design/#Propagators","page":"Design","title":"Propagators","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"inject! and extract are provided to ","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"The global propagator can be set to a CompositePropagator, with multiple dispatch, each inner propagator can be customized to handle different contexts and carriers.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"TextMapPropagator is not implemented yet! Personally I feel that every propagator may depends on a third party package. To minimize the dependencies of OpenTelemetryAPI.jl, those specialized propagators can be registered as independent packages.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"inject!\nextract","category":"page"},{"location":"design/#OpenTelemetryAPI.inject!","page":"Design","title":"OpenTelemetryAPI.inject!","text":"inject(carrier, [global_propagator], [current_context])\n\nInjects the value into a carrier. For example, into the headers of an HTTP request.\n\n\n\n\n\n","category":"function"},{"location":"design/#OpenTelemetryAPI.extract","page":"Design","title":"OpenTelemetryAPI.extract","text":"extract(carrier, [global_propagator], [current_context])\n\nExtracts the value from an incoming request. For example, from the headers of an HTTP request.\n\n\n\n\n\n","category":"function"},{"location":"design/#Trace","page":"Design","title":"Trace","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"The relationship between trace provider, tracer, span context and span is depicted below:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"┌────────────────────────────┐\n│Span                        │\n│                            │\n│ tracer                     │\n│   ┌──────────────────────┐ │\n│   │Tracer                │ │\n│   │                      │ │\n│   │  provider            │ │\n│   │   ┌────────────────┐ │ │\n│   │   │    Abstract    │ │ │\n│   │   │ TracerProvider │ │ │\n│   │   └────────────────┘ │ │\n│   │  instrumentation     │ │\n│   │   ┌────────────────┐ │ │\n│   │   │ name           │ │ │\n│   │   │ version        │ │ │\n│   │   └────────────────┘ │ │\n│   │                      │ │\n│   └──────────────────────┘ │\n│ span_context               │\n│   ┌──────────────────────┐ │\n│   │ trace_id             │ │\n│   │ span_id              │ │\n│   │ is_remote            │ │\n│   │ trace_flag           │ │\n│   │ trace_state          │ │\n│   └──────────────────────┘ │\n│ parent_span_context        │\n│ kind                       │\n│ start_time                 │\n│ end_time                   │\n│ attributes                 │\n│ links                      │\n│ events                     │\n│ status                     │\n└────────────────────────────┘","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"In OpenTelemetryAPI.jl, only one AbstractTracerProvider (DummyTracerProvider) is provided and is set as the global_tracer_provider.\nSpan is immutable. Modifiable fields like status, end_time are set to Ref.\nTo add Events and Links, users can call push!(span, event_or_link).\nThe attributes in the Span is a DynamicAttrs, and can be updated with the syntax like span[key]=value.\nend_time will be set by default after the call to with_span.\nAlways use set_status! to update the status of span.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"note: Note\nIn some other languages, only a dummy span is defined in API and the concrete span is defined in SDK. Personally I prefer to defined it in API, otherwise we need to define many getter methods.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"global_tracer_provider\nTracer\nSpan\ncurrent_span\nwith_span\nBase.push!(s::Span, ex::Exception)\nBase.push!(s::Span, link::Link)\nBase.setindex!(s::Span, val, key)\nBase.getindex(s::Span, key)\nset_status!\nend!\nis_recording","category":"page"},{"location":"design/#OpenTelemetryAPI.global_tracer_provider","page":"Design","title":"OpenTelemetryAPI.global_tracer_provider","text":"get the global tracer provider\n\n\n\n\n\nset the global tracer provider to p\n\n\n\n\n\n","category":"function"},{"location":"design/#OpenTelemetryAPI.Tracer","page":"Design","title":"OpenTelemetryAPI.Tracer","text":"Tracer(;provider=global_tracer_provider(), instrumentation=InstrumentationInfo())\n\nFor instrumentation library developers, instrumentation must be configured clearly instead of the default value.\n\n\n\n\n\n","category":"type"},{"location":"design/#OpenTelemetryAPI.Span","page":"Design","title":"OpenTelemetryAPI.Span","text":"Span(name::String, tracer::Tracer{TracerProvider};kw...)\n\nKeyword Arguments\n\ncontext=current_context(),\nkind=SPAN_KIND_INTERNAL,\nattributes=Dict{String, TAttrVal}(),\nlinks=Link[],\nevents=Event[],\nstart_time::UInt=time()*10^9, the nanoseconds.\nis_remote=false\n\n\n\n\n\n","category":"type"},{"location":"design/#OpenTelemetryAPI.current_span","page":"Design","title":"OpenTelemetryAPI.current_span","text":"current_span([current_context])\n\nGet the span in the current context.\n\n\n\n\n\n","category":"function"},{"location":"design/#OpenTelemetryAPI.with_span","page":"Design","title":"OpenTelemetryAPI.with_span","text":"with_span(f, s::AbstractSpan;kw...)\n\nCall function f with the current span set to s.\n\nKeyword arguments\n\nend_on_exit=true, controls whether to call end! after f or not.\nrecord_exception=true, controls whether to record the exception.\nset_status_on_exception=true, decides whether to set status to SPAN_STATUS_ERROR automatically when an exception is caught.\n\n\n\n\n\n","category":"function"},{"location":"design/#Base.push!-Tuple{Span, Exception}","page":"Design","title":"Base.push!","text":"A specialized variant of add_event! to record exceptions. Usually used in a try... catch...end to capture the backtrace. If the ex is rethrowed in the catch...end, is_rethrow_followed should be set to true.\n\n\n\n\n\n","category":"method"},{"location":"design/#Base.setindex!-Tuple{Span, Any, Any}","page":"Design","title":"Base.setindex!","text":"(s::Span)[key] = val\n\nSet the attributes in span s. Only valid when the span is not ended yet.\n\n\n\n\n\n","category":"method"},{"location":"design/#OpenTelemetryAPI.set_status!","page":"Design","title":"OpenTelemetryAPI.set_status!","text":"set_status!(s::Span, code::SpanStatusCode, description=nothing)\n\nUpdate the status of span s by following the original specification. description is only considered when the code is SPAN_STATUS_ERROR. Only valid when the span is not ended yet.\n\n\n\n\n\n","category":"function"},{"location":"design/#OpenTelemetryAPI.end!","page":"Design","title":"OpenTelemetryAPI.end!","text":"end!(s::Span, t=UInt(time()*10^9))\n\nSet the end time of the span and trigger span processors.\n\n\n\n\n\n","category":"function"},{"location":"design/#OpenTelemetryAPI.is_recording","page":"Design","title":"OpenTelemetryAPI.is_recording","text":"is_recording(s::Span)\n\nReturns true if this span s is recording information like Event operations, attribute modification using setindex!, etc.\n\n\n\n\n\n","category":"function"},{"location":"design/","page":"Design","title":"Design","text":"Some other exported symbols:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"TraceIdType\nSpanIdType\nINVALID_TRACE_ID\nINVALID_SPAN_ID\ncurrent_span\nTraceFlag\nTraceState\nSpanContext\nINVALID_SPAN_CONTEXT\nspan_context\nSPAN_KIND_UNSPECIFIED\nSPAN_KIND_INTERNAL\nSPAN_KIND_SERVER\nSPAN_KIND_CLIENT\nSPAN_KIND_PRODUCER\nSPAN_KIND_CONSUMER\nLimitInfo\nLink\nEvent\nSPAN_STATUS_UNSET\nSPAN_STATUS_OK\nSPAN_STATUS_ERROR\nSpanStatu","category":"page"},{"location":"design/#OpenTelemetryAPI.TraceState","page":"Design","title":"OpenTelemetryAPI.TraceState","text":"TraceState(entries::Pair{String,String}...)\n\nTraceState carries vendor-specific trace identification data, represented as a list of key-value pairs. TraceState allows multiple tracing systems to participate in the same trace. It is fully described in the W3C Trace Context specification.\n\n\n\n\n\n","category":"type"},{"location":"design/#OpenTelemetryAPI.SpanContext","page":"Design","title":"OpenTelemetryAPI.SpanContext","text":"SpanContext(;span_id, trace_id, is_remote, trace_flag=TraceFlag(), trace_state=TraceState())\n\nA SpanContext represents the portion of a Span which must be serialized and propagated along side of a distributed context. SpanContexts are immutable.\n\nThe OpenTelemetry SpanContext representation conforms to the W3C TraceContext specification. It contains two identifiers - a TraceId and a SpanId - along with a set of common TraceFlags and system-specific TraceState values.\n\nTraceId A valid trace identifier is a 16-byte array with at least one non-zero byte.\n\nSpanId A valid span identifier is an 8-byte array with at least one non-zero byte.\n\nTraceFlags contain details about the trace. Unlike TraceState values, TraceFlags are present in all traces. The current version of the specification only supports a single flag called sampled.\n\nTraceState carries vendor-specific trace identification data, represented as a list of key-value pairs. TraceState allows multiple tracing systems to participate in the same trace. It is fully described in the W3C Trace Context specification.\n\n\n\n\n\n","category":"type"},{"location":"design/#OpenTelemetryAPI.span_context","page":"Design","title":"OpenTelemetryAPI.span_context","text":"span_context([s::Span])\n\nGet the SpanContext from a span s. If s is not specified, current_span() will be used. nothing is returned if no span context found.\n\n\n\n\n\n","category":"function"},{"location":"design/#OpenTelemetryAPI.LimitInfo","page":"Design","title":"OpenTelemetryAPI.LimitInfo","text":"LimitInfo(;kw...)\n\nUsed in TracerProvider to configure generated Tracer.\n\nKeyword arguments:\n\nspan_attribute_count_limit::Int = 128\nspan_attribute_value_length_limit::Union{Nothing,Int} = nothing\nspan_event_count_limit::Int = 128\nspan_link_count_limit::Int = 128\n\n\n\n\n\n","category":"type"},{"location":"design/#OpenTelemetryAPI.Link","page":"Design","title":"OpenTelemetryAPI.Link","text":"Link(span_context, attributes)\n\nSee more details at links between spans.\n\n\n\n\n\n","category":"type"},{"location":"design/#OpenTelemetryAPI.Event","page":"Design","title":"OpenTelemetryAPI.Event","text":"Event(name, timestamp=time()*10^9, attributes=StaticAttrs())\n\ntimestamp is the nanoseconds.\n\n\n\n\n\n","category":"type"},{"location":"design/#Metric","page":"Design","title":"Metric","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"The relationship between MeterProvider, Meter and different instruments are depicted below:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":" ┌─────────────────────────────┐\n │AbstractInstrument           │\n │                             │\n │  name                       │\n │  unit                       │\n │  description                │\n │                             │\n │  meter                      │\n │   ┌───────────────────────┐ │\n │   │Meter                  │ │\n │   │                       │ │\n │   │  provider             │ │\n │   │   ┌────────────────┐  │ │\n │   │   │   Abstract     │  │ │\n │   │   │ MeterProvider  │  │ │\n │   │   └────────────────┘  │ │\n │   │  name                 │ │\n │   │  version              │ │\n │   │  schema_url           │ │\n │   │                       │ │\n │   │  instrumentation      │ │\n │   │   ┌────────────────┐  │ │\n │   │   │ name           │  │ │\n │   │   │ version        │  │ │\n │   │   └────────────────┘  │ │\n │   │  instruments          │ │\n │   │                       │ │\n │   │    * Counter          │ │\n │   │    * Histogram        │ │\n │   │    * UpDownCounter    │ │\n │   │    * ObservableCounter│ │\n │   │    * Observable       │ │\n │   │      UpDownCounter    │ │\n │   └───────────────────────┘ │\n │                             │\n └─────────────────────────────┘","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"An Instrument belongs to a Meter, each Meter may contain many different Instruments. Similarly, a Meter belongs to a MeterProvider and a MeterProvider may contain many different Meters.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"global_meter_provider\nMeter\nMeasurement\nCounter\nObservableCounter\nHistogram\nObservableGauge\nUpDownCounter\nObservableUpDownCounter","category":"page"},{"location":"design/#SDK","page":"Design","title":"SDK","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"Two common exporters are provided to for debugging:","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"InMemoryExporter\nConsoleExporter","category":"page"},{"location":"design/#Trace-2","page":"Design","title":"Trace","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"In SDK, a dedicated TraceProvider is provided.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"TraceProvider\nCompositSpanProcessor\nALWAYS_ON\nALWAYS_OFF\nDEFAULT_ON\nDEFAULT_OFF\nTraceIdRatioBased","category":"page"},{"location":"design/#OpenTelemetrySDK.CompositSpanProcessor","page":"Design","title":"OpenTelemetrySDK.CompositSpanProcessor","text":"CompositSpanProcessor(processors...)\n\nA wrapper of different concrete span processors. Users can also push! new span processors into it after construction.\n\nSee also SimpleSpanProcessor.\n\n\n\n\n\n","category":"type"},{"location":"design/#OpenTelemetrySDK.DEFAULT_ON","page":"Design","title":"OpenTelemetrySDK.DEFAULT_ON","text":"Sampler that respects its parent span's sampling decision, but otherwise always samples.\n\n\n\n\n\n","category":"constant"},{"location":"design/#OpenTelemetrySDK.DEFAULT_OFF","page":"Design","title":"OpenTelemetrySDK.DEFAULT_OFF","text":"Sampler that respects its parent span's sampling decision, but otherwise never samples.\n\n\n\n\n\n","category":"constant"},{"location":"design/#Metric-2","page":"Design","title":"Metric","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"The current implementation of metrics in SDK is mainly inspired by the dotnet sdk.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"┌──────────────────────────────────────────┐\n│MeterProvider                             │\n│                                          │\n│  meters                                  │\n│  views                                   │\n│                                          │\n│  instrument_associated_metric_names      │\n│    instrument =>  Set{metric_name}       │\n│                                          │\n│  metrics                                 │\n│    name => metric                        │\n│    ┌───────────────────────────────────┐ │\n│    │Metric                             │ │\n│    │                                   │ │\n│    │  name                             │ │\n│    │  description                      │ │\n│    │  criteria                         │ │\n│    │  aggregation                      │ │\n│    │    ┌──────────────────────────┐   │ │\n│    │    │AggregationStore          │   │ │\n│    │    │                          │   │ │\n│    │    │  attributes => data_point│   │ │\n│    │    │   ┌─────────────────┐    │   │ │\n│    │    │   │AbstractDataPoint│    │   │ │\n│    │    │   │                 │    │   │ │\n│    │    │   │  value          │    │   │ │\n│    │    │   │  start_time     │    │   │ │\n│    │    │   │  end_time       │    │   │ │\n│    │    │   │  exemplars      │    │   │ │\n│    │    │   │ ┌────────────┐  │    │   │ │\n│    │    │   │ │Exemplar    │  │    │   │ │\n│    │    │   │ │            │  │    │   │ │\n│    │    │   │ │ value      │  │    │   │ │\n│    │    │   │ │ trace_id   │  │    │   │ │\n│    │    │   │ │ span_id    │  │    │   │ │\n│    │    │   │ └────────────┘  │    │   │ │\n│    │    │   │                 │    │   │ │\n│    │    │   └─────────────────┘    │   │ │\n│    │    │                          │   │ │\n│    │    └──────────────────────────┘   │ │\n│    │                                   │ │\n│    └───────────────────────────────────┘ │\n│                                          │\n└──────────────────────────────────────────┘","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"A View specifies which instruments are grouped together through Criteria. For each view, a Metric is created to store the Measurements. Each metric may have many different dimensions configured by StaticAttrs in a Measurement. For each dimension, we may also collect those [Exemplar]s in the mean while.","category":"page"},{"location":"design/#Design-decisions","page":"Design","title":"Design decisions","text":"","category":"section"},{"location":"design/","page":"Design","title":"Design","text":"For each registered instrument, we have stored the associated metrics configured by views into the instrument_associated_metric_names field. So that for each pair of instrument => measurement, we can quickly determine which metrics to update.\nThe make sure that measurements with the same attribute key-values but with different order can be updated in the same dimension in the AggregationStore, a design from opentelemetry-dotnet#2374 is borrowed here.","category":"page"},{"location":"design/","page":"Design","title":"Design","text":"MeterProvider\nView\nMetric\nAggregationStore","category":"page"},{"location":"design_api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"design_api/","page":"API","title":"API","text":"The content in this page is organized in the same order as the OpenTelemetry Specification.","category":"page"},{"location":"design_api/#Context","page":"API","title":"Context","text":"","category":"section"},{"location":"design_api/","page":"API","title":"API","text":"Context is implemented as a wrapper of NamedTuple, which means it is immutable. Each Task has exactly ONE Context instance, which is injected into the task_local_storage of the current_task by the parent task automatically.","category":"page"},{"location":"design_api/","page":"API","title":"API","text":"warning: Warning\nType piracy is used to the propagate context between tasks.","category":"page"},{"location":"design_api/","page":"API","title":"API","text":"create_key is used to create a context key. But it is not exported yet because it seems to be only used internally until now.","category":"page"},{"location":"design_api/","page":"API","title":"API","text":"Base.getindex(::Context, key) is implemented so to get a value in a Context, one can simply call ctx[key] to get the associated value of a key in a ctx.","category":"page"},{"location":"design_api/","page":"API","title":"API","text":"Setting value of a Context is not directly supported. Given that Context is immutable, updating an immutable object in Julia seems strange. We provide the with_context function to create a new context based on the key-value pairs in the current_context. This syntax is more common than the attach/detach operations in the original specification.","category":"page"},{"location":"design_api/","page":"API","title":"API","text":"with_context\ncurrent_context","category":"page"},{"location":"design_api/#Propagators","page":"API","title":"Propagators","text":"","category":"section"},{"location":"design_api/","page":"API","title":"API","text":"inject! and extract are provided to ","category":"page"},{"location":"design_api/","page":"API","title":"API","text":"The global propagator can be set to a CompositePropagator, with multiple dispatch, each inner propagator can be customized to handle different contexts and carriers.","category":"page"},{"location":"design_api/","page":"API","title":"API","text":"TextMapPropagator is not implemented yet! Personally I feel that every propagator may depends on a third party package. To minimize the dependencies of OpenTelemetryAPI.jl, those specialized propagators can be registered as independent packages.","category":"page"},{"location":"design_api/","page":"API","title":"API","text":"inject!\nextract","category":"page"},{"location":"design_api/#Trace","page":"API","title":"Trace","text":"","category":"section"},{"location":"design_api/","page":"API","title":"API","text":"The relationship between trace provider, tracer, span context and span is depicted below:","category":"page"},{"location":"design_api/","page":"API","title":"API","text":"┌────────────────────────────┐\n│Span                        │\n│                            │\n│ tracer                     │\n│   ┌──────────────────────┐ │\n│   │Tracer                │ │\n│   │                      │ │\n│   │  provider            │ │\n│   │   ┌────────────────┐ │ │\n│   │   │    Abstract    │ │ │\n│   │   │ TracerProvider │ │ │\n│   │   └────────────────┘ │ │\n│   │  instrumentation     │ │\n│   │   ┌────────────────┐ │ │\n│   │   │ name           │ │ │\n│   │   │ version        │ │ │\n│   │   └────────────────┘ │ │\n│   │                      │ │\n│   └──────────────────────┘ │\n│ span_context               │\n│   ┌──────────────────────┐ │\n│   │ trace_id             │ │\n│   │ span_id              │ │\n│   │ is_remote            │ │\n│   │ trace_flag           │ │\n│   │ trace_state          │ │\n│   └──────────────────────┘ │\n│ parent_span_context        │\n│ kind                       │\n│ start_time                 │\n│ end_time                   │\n│ attributes                 │\n│ links                      │\n│ events                     │\n│ status                     │\n└────────────────────────────┘","category":"page"},{"location":"design_api/","page":"API","title":"API","text":"In OpenTelemetryAPI.jl, only one AbstractTracerProvider (DummyTracerProvider) is provided and is set as the global_tracer_provider.\nSpan is immutable. Modifiable fields like status, end_time are set to Ref.\nTo add Events and Links, users can call push!(span, event_or_link).\nThe attributes in the Span is a DynamicAttrs, and can be updated with the syntax like span[key]=value.\nend_time will be set by default after the call to with_span.\nAlways use set_status! to update the status of span.","category":"page"},{"location":"design_api/","page":"API","title":"API","text":"note: Note\nIn some other languages, only a dummy span is defined in API and the concrete span is defined in SDK. Personally I prefer to defined it in API, otherwise we need to define many getter methods.","category":"page"},{"location":"design_api/","page":"API","title":"API","text":"global_tracer_provider\nTracer\nSpan\ncurrent_span\nwith_span\nBase.push!(s::Span, ex::Exception)\nBase.push!(s::Span, link::Link)\nBase.setindex!(s::Span, val, key)\nBase.getindex(s::Span, key)\nset_status!\nend!\nis_recording","category":"page"},{"location":"design_api/","page":"API","title":"API","text":"Some other exported symbols:","category":"page"},{"location":"design_api/","page":"API","title":"API","text":"TraceIdType\nSpanIdType\nINVALID_TRACE_ID\nINVALID_SPAN_ID\ncurrent_span\nTraceFlag\nTraceState\nSpanContext\nINVALID_SPAN_CONTEXT\nspan_context\nSPAN_KIND_UNSPECIFIED\nSPAN_KIND_INTERNAL\nSPAN_KIND_SERVER\nSPAN_KIND_CLIENT\nSPAN_KIND_PRODUCER\nSPAN_KIND_CONSUMER\nLimitInfo\nLink\nEvent\nSPAN_STATUS_UNSET\nSPAN_STATUS_OK\nSPAN_STATUS_ERROR\nSpanStatu","category":"page"},{"location":"design_api/#Metric","page":"API","title":"Metric","text":"","category":"section"},{"location":"design_api/","page":"API","title":"API","text":"The relationship between MeterProvider, Meter and different instruments are depicted below:","category":"page"},{"location":"design_api/","page":"API","title":"API","text":" ┌─────────────────────────────┐\n │AbstractInstrument           │\n │                             │\n │  name                       │\n │  unit                       │\n │  description                │\n │                             │\n │  meter                      │\n │   ┌───────────────────────┐ │\n │   │Meter                  │ │\n │   │                       │ │\n │   │  provider             │ │\n │   │   ┌────────────────┐  │ │\n │   │   │   Abstract     │  │ │\n │   │   │ MeterProvider  │  │ │\n │   │   └────────────────┘  │ │\n │   │  name                 │ │\n │   │  version              │ │\n │   │  schema_url           │ │\n │   │                       │ │\n │   │  instrumentation      │ │\n │   │   ┌────────────────┐  │ │\n │   │   │ name           │  │ │\n │   │   │ version        │  │ │\n │   │   └────────────────┘  │ │\n │   │  instruments          │ │\n │   │                       │ │\n │   │    * Counter          │ │\n │   │    * Histogram        │ │\n │   │    * UpDownCounter    │ │\n │   │    * ObservableCounter│ │\n │   │    * Observable       │ │\n │   │      UpDownCounter    │ │\n │   └───────────────────────┘ │\n │                             │\n └─────────────────────────────┘","category":"page"},{"location":"design_api/","page":"API","title":"API","text":"An Instrument belongs to a Meter, each Meter may contain many different Instruments. Similarly, a Meter belongs to a MeterProvider and a MeterProvider may contain many different Meters.","category":"page"},{"location":"design_api/","page":"API","title":"API","text":"global_meter_provider\nMeter\nMeasurement\nCounter\nObservableCounter\nHistogram\nObservableGauge\nUpDownCounter\nObservableUpDownCounter","category":"page"},{"location":"#OpenTelemetry.jl","page":"Home","title":"OpenTelemetry.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: doc) (Image: CI) (Image: codecov) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages)","category":"page"},{"location":"","page":"Home","title":"Home","text":"An unofficial implementation of OpenTelemetry in Julia.","category":"page"},{"location":"#Packages","page":"Home","title":"Packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Package Latest Version Status\nOpenTelemetry (Image: version) (Image: pkgeval)\nOpenTelemetryAPI (Image: version) (Image: pkgeval)\nOpenTelemetrySDK (Image: version) (Image: pkgeval)\nOpenTelemetryProto (Image: version) (Image: pkgeval)\nOpenTelemetryExporterOtlpProtoGrpc (Image: version) (Image: pkgeval)\nOpenTelemetryExporterPrometheus (Image: version) (Image: pkgeval)","category":"page"},{"location":"#Progress","page":"Home","title":"Progress","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"API\n[x] Tracing\n[x] Metrics\n[x] Logging\nSDK\n[x] Tracing\n[x] Metric\nExporter\nOTLP\n[x] Tracing\n[ ] Metrics\n[x] Prometheus\nInstrumentation\nStd Lib\n[ ] Core\n[ ] Sockets\n[ ] Distributed\n[ ] Downloads\nCommon Packages\n[ ] HTTP\n[ ] Genie","category":"page"},{"location":"#Get-Started","page":"Home","title":"Get Started","text":"","category":"section"},{"location":"#Traces","page":"Home","title":"Traces","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To show traces in your console:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using OpenTelemetry\n\ntracer = Tracer(\n    provider = TracerProvider(\n        span_processor = SimpleSpanProcessor(\n            ConsoleExporter()\n        )\n    )\n);\n\nwith_span(Span(\"Hello\", tracer)) do\n    println(\"World!\")\nend","category":"page"},{"location":"#Metrics","page":"Home","title":"Metrics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using OpenTelemetry\n\np = MeterProvider();\ne = ConsoleExporter();\nr = MetricReader(p, e);\n\nm = Meter(\"my_metrics\"; provider=p);\nc = Counter{Int}(\"fruit_counter\", m);\n\nc(; name = \"apple\", color = \"red\")\nc(2; name = \"lemon\", color = \"yellow\")\nc(1; name = \"lemon\", color = \"yellow\")\nc(2; name = \"apple\", color = \"green\")\nc(5; name = \"apple\", color = \"red\")\nc(4; name = \"lemon\", color = \"yellow\")\n\nr()","category":"page"},{"location":"#Logging","page":"Home","title":"Logging","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using OpenTelemetry\nusing Logging\nusing LoggingExtras\n\nwith_logger(TransformerLogger(LogTransformer(), global_logger())) do\n    @info \"hello world!\"\nend","category":"page"},{"location":"#Benchmarks","page":"Home","title":"Benchmarks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Check out the benchmark results with Julia@v1.6, Julia@v1.7.","category":"page"}]
}
