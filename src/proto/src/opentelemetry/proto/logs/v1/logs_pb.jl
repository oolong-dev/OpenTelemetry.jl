# Autogenerated using ProtoBuf.jl v1.0.9 on 2023-03-01T12:24:55.791
# original file: /home/tj/workspace/git/OpenTelemetry.jl/src/proto/dev/opentelemetry-proto-0.19.0/opentelemetry/proto/logs/v1/logs.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export LogRecordFlags, SeverityNumber, LogRecord, ScopeLogs, ResourceLogs, LogsData

@enumx LogRecordFlags LOG_RECORD_FLAG_UNSPECIFIED=0 LOG_RECORD_FLAG_TRACE_FLAGS_MASK=255

@enumx SeverityNumber SEVERITY_NUMBER_UNSPECIFIED=0 SEVERITY_NUMBER_TRACE=1 SEVERITY_NUMBER_TRACE2=2 SEVERITY_NUMBER_TRACE3=3 SEVERITY_NUMBER_TRACE4=4 SEVERITY_NUMBER_DEBUG=5 SEVERITY_NUMBER_DEBUG2=6 SEVERITY_NUMBER_DEBUG3=7 SEVERITY_NUMBER_DEBUG4=8 SEVERITY_NUMBER_INFO=9 SEVERITY_NUMBER_INFO2=10 SEVERITY_NUMBER_INFO3=11 SEVERITY_NUMBER_INFO4=12 SEVERITY_NUMBER_WARN=13 SEVERITY_NUMBER_WARN2=14 SEVERITY_NUMBER_WARN3=15 SEVERITY_NUMBER_WARN4=16 SEVERITY_NUMBER_ERROR=17 SEVERITY_NUMBER_ERROR2=18 SEVERITY_NUMBER_ERROR3=19 SEVERITY_NUMBER_ERROR4=20 SEVERITY_NUMBER_FATAL=21 SEVERITY_NUMBER_FATAL2=22 SEVERITY_NUMBER_FATAL3=23 SEVERITY_NUMBER_FATAL4=24

struct LogRecord
    time_unix_nano::UInt64
    observed_time_unix_nano::UInt64
    severity_number::SeverityNumber.T
    severity_text::String
    body::Union{Nothing,opentelemetry.proto.common.v1.AnyValue}
    attributes::Vector{opentelemetry.proto.common.v1.KeyValue}
    dropped_attributes_count::UInt32
    flags::UInt32
    trace_id::Vector{UInt8}
    span_id::Vector{UInt8}
end
PB.reserved_fields(::Type{LogRecord}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[4])
PB.default_values(::Type{LogRecord}) = (;time_unix_nano = zero(UInt64), observed_time_unix_nano = zero(UInt64), severity_number = SeverityNumber.SEVERITY_NUMBER_UNSPECIFIED, severity_text = "", body = nothing, attributes = Vector{opentelemetry.proto.common.v1.KeyValue}(), dropped_attributes_count = zero(UInt32), flags = zero(UInt32), trace_id = UInt8[], span_id = UInt8[])
PB.field_numbers(::Type{LogRecord}) = (;time_unix_nano = 1, observed_time_unix_nano = 11, severity_number = 2, severity_text = 3, body = 5, attributes = 6, dropped_attributes_count = 7, flags = 8, trace_id = 9, span_id = 10)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LogRecord})
    time_unix_nano = zero(UInt64)
    observed_time_unix_nano = zero(UInt64)
    severity_number = SeverityNumber.SEVERITY_NUMBER_UNSPECIFIED
    severity_text = ""
    body = Ref{Union{Nothing,opentelemetry.proto.common.v1.AnyValue}}(nothing)
    attributes = PB.BufferedVector{opentelemetry.proto.common.v1.KeyValue}()
    dropped_attributes_count = zero(UInt32)
    flags = zero(UInt32)
    trace_id = UInt8[]
    span_id = UInt8[]
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            time_unix_nano = PB.decode(d, UInt64, Val{:fixed})
        elseif field_number == 11
            observed_time_unix_nano = PB.decode(d, UInt64, Val{:fixed})
        elseif field_number == 2
            severity_number = PB.decode(d, SeverityNumber.T)
        elseif field_number == 3
            severity_text = PB.decode(d, String)
        elseif field_number == 5
            PB.decode!(d, body)
        elseif field_number == 6
            PB.decode!(d, attributes)
        elseif field_number == 7
            dropped_attributes_count = PB.decode(d, UInt32)
        elseif field_number == 8
            flags = PB.decode(d, UInt32, Val{:fixed})
        elseif field_number == 9
            trace_id = PB.decode(d, Vector{UInt8})
        elseif field_number == 10
            span_id = PB.decode(d, Vector{UInt8})
        else
            PB.skip(d, wire_type)
        end
    end
    return LogRecord(time_unix_nano, observed_time_unix_nano, severity_number, severity_text, body[], attributes[], dropped_attributes_count, flags, trace_id, span_id)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LogRecord)
    initpos = position(e.io)
    x.time_unix_nano != zero(UInt64) && PB.encode(e, 1, x.time_unix_nano, Val{:fixed})
    x.observed_time_unix_nano != zero(UInt64) && PB.encode(e, 11, x.observed_time_unix_nano, Val{:fixed})
    x.severity_number != SeverityNumber.SEVERITY_NUMBER_UNSPECIFIED && PB.encode(e, 2, x.severity_number)
    !isempty(x.severity_text) && PB.encode(e, 3, x.severity_text)
    !isnothing(x.body) && PB.encode(e, 5, x.body)
    !isempty(x.attributes) && PB.encode(e, 6, x.attributes)
    x.dropped_attributes_count != zero(UInt32) && PB.encode(e, 7, x.dropped_attributes_count)
    x.flags != zero(UInt32) && PB.encode(e, 8, x.flags, Val{:fixed})
    !isempty(x.trace_id) && PB.encode(e, 9, x.trace_id)
    !isempty(x.span_id) && PB.encode(e, 10, x.span_id)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LogRecord)
    encoded_size = 0
    x.time_unix_nano != zero(UInt64) && (encoded_size += PB._encoded_size(x.time_unix_nano, 1, Val{:fixed}))
    x.observed_time_unix_nano != zero(UInt64) && (encoded_size += PB._encoded_size(x.observed_time_unix_nano, 11, Val{:fixed}))
    x.severity_number != SeverityNumber.SEVERITY_NUMBER_UNSPECIFIED && (encoded_size += PB._encoded_size(x.severity_number, 2))
    !isempty(x.severity_text) && (encoded_size += PB._encoded_size(x.severity_text, 3))
    !isnothing(x.body) && (encoded_size += PB._encoded_size(x.body, 5))
    !isempty(x.attributes) && (encoded_size += PB._encoded_size(x.attributes, 6))
    x.dropped_attributes_count != zero(UInt32) && (encoded_size += PB._encoded_size(x.dropped_attributes_count, 7))
    x.flags != zero(UInt32) && (encoded_size += PB._encoded_size(x.flags, 8, Val{:fixed}))
    !isempty(x.trace_id) && (encoded_size += PB._encoded_size(x.trace_id, 9))
    !isempty(x.span_id) && (encoded_size += PB._encoded_size(x.span_id, 10))
    return encoded_size
end

struct ScopeLogs
    scope::Union{Nothing,opentelemetry.proto.common.v1.InstrumentationScope}
    log_records::Vector{LogRecord}
    schema_url::String
end
PB.default_values(::Type{ScopeLogs}) = (;scope = nothing, log_records = Vector{LogRecord}(), schema_url = "")
PB.field_numbers(::Type{ScopeLogs}) = (;scope = 1, log_records = 2, schema_url = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ScopeLogs})
    scope = Ref{Union{Nothing,opentelemetry.proto.common.v1.InstrumentationScope}}(nothing)
    log_records = PB.BufferedVector{LogRecord}()
    schema_url = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, scope)
        elseif field_number == 2
            PB.decode!(d, log_records)
        elseif field_number == 3
            schema_url = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return ScopeLogs(scope[], log_records[], schema_url)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ScopeLogs)
    initpos = position(e.io)
    !isnothing(x.scope) && PB.encode(e, 1, x.scope)
    !isempty(x.log_records) && PB.encode(e, 2, x.log_records)
    !isempty(x.schema_url) && PB.encode(e, 3, x.schema_url)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ScopeLogs)
    encoded_size = 0
    !isnothing(x.scope) && (encoded_size += PB._encoded_size(x.scope, 1))
    !isempty(x.log_records) && (encoded_size += PB._encoded_size(x.log_records, 2))
    !isempty(x.schema_url) && (encoded_size += PB._encoded_size(x.schema_url, 3))
    return encoded_size
end

struct ResourceLogs
    resource::Union{Nothing,opentelemetry.proto.resource.v1.Resource}
    scope_logs::Vector{ScopeLogs}
    schema_url::String
end
PB.reserved_fields(::Type{ResourceLogs}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[1000])
PB.default_values(::Type{ResourceLogs}) = (;resource = nothing, scope_logs = Vector{ScopeLogs}(), schema_url = "")
PB.field_numbers(::Type{ResourceLogs}) = (;resource = 1, scope_logs = 2, schema_url = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ResourceLogs})
    resource = Ref{Union{Nothing,opentelemetry.proto.resource.v1.Resource}}(nothing)
    scope_logs = PB.BufferedVector{ScopeLogs}()
    schema_url = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, resource)
        elseif field_number == 2
            PB.decode!(d, scope_logs)
        elseif field_number == 3
            schema_url = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return ResourceLogs(resource[], scope_logs[], schema_url)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ResourceLogs)
    initpos = position(e.io)
    !isnothing(x.resource) && PB.encode(e, 1, x.resource)
    !isempty(x.scope_logs) && PB.encode(e, 2, x.scope_logs)
    !isempty(x.schema_url) && PB.encode(e, 3, x.schema_url)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ResourceLogs)
    encoded_size = 0
    !isnothing(x.resource) && (encoded_size += PB._encoded_size(x.resource, 1))
    !isempty(x.scope_logs) && (encoded_size += PB._encoded_size(x.scope_logs, 2))
    !isempty(x.schema_url) && (encoded_size += PB._encoded_size(x.schema_url, 3))
    return encoded_size
end

struct LogsData
    resource_logs::Vector{ResourceLogs}
end
PB.default_values(::Type{LogsData}) = (;resource_logs = Vector{ResourceLogs}())
PB.field_numbers(::Type{LogsData}) = (;resource_logs = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LogsData})
    resource_logs = PB.BufferedVector{ResourceLogs}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, resource_logs)
        else
            PB.skip(d, wire_type)
        end
    end
    return LogsData(resource_logs[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LogsData)
    initpos = position(e.io)
    !isempty(x.resource_logs) && PB.encode(e, 1, x.resource_logs)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LogsData)
    encoded_size = 0
    !isempty(x.resource_logs) && (encoded_size += PB._encoded_size(x.resource_logs, 1))
    return encoded_size
end
