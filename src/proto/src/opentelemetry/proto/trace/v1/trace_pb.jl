# Autogenerated using ProtoBuf.jl v1.0.9 on 2023-03-01T12:14:45.168
# original file: /home/tj/workspace/git/OpenTelemetry.jl/src/proto/dev/opentelemetry-proto-0.19.0/opentelemetry/proto/trace/v1/trace.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export var"Span.SpanKind", var"Span.Event", var"Status.StatusCode", var"Span.Link", Status
export Span, ScopeSpans, ResourceSpans, TracesData

@enumx var"Span.SpanKind" SPAN_KIND_UNSPECIFIED=0 SPAN_KIND_INTERNAL=1 SPAN_KIND_SERVER=2 SPAN_KIND_CLIENT=3 SPAN_KIND_PRODUCER=4 SPAN_KIND_CONSUMER=5

struct var"Span.Event"
    time_unix_nano::UInt64
    name::String
    attributes::Vector{opentelemetry.proto.common.v1.KeyValue}
    dropped_attributes_count::UInt32
end
PB.default_values(::Type{var"Span.Event"}) = (;time_unix_nano = zero(UInt64), name = "", attributes = Vector{opentelemetry.proto.common.v1.KeyValue}(), dropped_attributes_count = zero(UInt32))
PB.field_numbers(::Type{var"Span.Event"}) = (;time_unix_nano = 1, name = 2, attributes = 3, dropped_attributes_count = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"Span.Event"})
    time_unix_nano = zero(UInt64)
    name = ""
    attributes = PB.BufferedVector{opentelemetry.proto.common.v1.KeyValue}()
    dropped_attributes_count = zero(UInt32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            time_unix_nano = PB.decode(d, UInt64, Val{:fixed})
        elseif field_number == 2
            name = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, attributes)
        elseif field_number == 4
            dropped_attributes_count = PB.decode(d, UInt32)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"Span.Event"(time_unix_nano, name, attributes[], dropped_attributes_count)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"Span.Event")
    initpos = position(e.io)
    x.time_unix_nano != zero(UInt64) && PB.encode(e, 1, x.time_unix_nano, Val{:fixed})
    !isempty(x.name) && PB.encode(e, 2, x.name)
    !isempty(x.attributes) && PB.encode(e, 3, x.attributes)
    x.dropped_attributes_count != zero(UInt32) && PB.encode(e, 4, x.dropped_attributes_count)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"Span.Event")
    encoded_size = 0
    x.time_unix_nano != zero(UInt64) && (encoded_size += PB._encoded_size(x.time_unix_nano, 1, Val{:fixed}))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 2))
    !isempty(x.attributes) && (encoded_size += PB._encoded_size(x.attributes, 3))
    x.dropped_attributes_count != zero(UInt32) && (encoded_size += PB._encoded_size(x.dropped_attributes_count, 4))
    return encoded_size
end

@enumx var"Status.StatusCode" STATUS_CODE_UNSET=0 STATUS_CODE_OK=1 STATUS_CODE_ERROR=2

struct var"Span.Link"
    trace_id::Vector{UInt8}
    span_id::Vector{UInt8}
    trace_state::String
    attributes::Vector{opentelemetry.proto.common.v1.KeyValue}
    dropped_attributes_count::UInt32
end
PB.default_values(::Type{var"Span.Link"}) = (;trace_id = UInt8[], span_id = UInt8[], trace_state = "", attributes = Vector{opentelemetry.proto.common.v1.KeyValue}(), dropped_attributes_count = zero(UInt32))
PB.field_numbers(::Type{var"Span.Link"}) = (;trace_id = 1, span_id = 2, trace_state = 3, attributes = 4, dropped_attributes_count = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"Span.Link"})
    trace_id = UInt8[]
    span_id = UInt8[]
    trace_state = ""
    attributes = PB.BufferedVector{opentelemetry.proto.common.v1.KeyValue}()
    dropped_attributes_count = zero(UInt32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            trace_id = PB.decode(d, Vector{UInt8})
        elseif field_number == 2
            span_id = PB.decode(d, Vector{UInt8})
        elseif field_number == 3
            trace_state = PB.decode(d, String)
        elseif field_number == 4
            PB.decode!(d, attributes)
        elseif field_number == 5
            dropped_attributes_count = PB.decode(d, UInt32)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"Span.Link"(trace_id, span_id, trace_state, attributes[], dropped_attributes_count)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"Span.Link")
    initpos = position(e.io)
    !isempty(x.trace_id) && PB.encode(e, 1, x.trace_id)
    !isempty(x.span_id) && PB.encode(e, 2, x.span_id)
    !isempty(x.trace_state) && PB.encode(e, 3, x.trace_state)
    !isempty(x.attributes) && PB.encode(e, 4, x.attributes)
    x.dropped_attributes_count != zero(UInt32) && PB.encode(e, 5, x.dropped_attributes_count)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"Span.Link")
    encoded_size = 0
    !isempty(x.trace_id) && (encoded_size += PB._encoded_size(x.trace_id, 1))
    !isempty(x.span_id) && (encoded_size += PB._encoded_size(x.span_id, 2))
    !isempty(x.trace_state) && (encoded_size += PB._encoded_size(x.trace_state, 3))
    !isempty(x.attributes) && (encoded_size += PB._encoded_size(x.attributes, 4))
    x.dropped_attributes_count != zero(UInt32) && (encoded_size += PB._encoded_size(x.dropped_attributes_count, 5))
    return encoded_size
end

struct Status
    message::String
    code::var"Status.StatusCode".T
end
PB.reserved_fields(::Type{Status}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[1])
PB.default_values(::Type{Status}) = (;message = "", code = var"Status.StatusCode".STATUS_CODE_UNSET)
PB.field_numbers(::Type{Status}) = (;message = 2, code = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Status})
    message = ""
    code = var"Status.StatusCode".STATUS_CODE_UNSET
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 2
            message = PB.decode(d, String)
        elseif field_number == 3
            code = PB.decode(d, var"Status.StatusCode".T)
        else
            PB.skip(d, wire_type)
        end
    end
    return Status(message, code)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Status)
    initpos = position(e.io)
    !isempty(x.message) && PB.encode(e, 2, x.message)
    x.code != var"Status.StatusCode".STATUS_CODE_UNSET && PB.encode(e, 3, x.code)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Status)
    encoded_size = 0
    !isempty(x.message) && (encoded_size += PB._encoded_size(x.message, 2))
    x.code != var"Status.StatusCode".STATUS_CODE_UNSET && (encoded_size += PB._encoded_size(x.code, 3))
    return encoded_size
end

struct Span
    trace_id::Vector{UInt8}
    span_id::Vector{UInt8}
    trace_state::String
    parent_span_id::Vector{UInt8}
    name::String
    kind::var"Span.SpanKind".T
    start_time_unix_nano::UInt64
    end_time_unix_nano::UInt64
    attributes::Vector{opentelemetry.proto.common.v1.KeyValue}
    dropped_attributes_count::UInt32
    events::Vector{var"Span.Event"}
    dropped_events_count::UInt32
    links::Vector{var"Span.Link"}
    dropped_links_count::UInt32
    status::Union{Nothing,Status}
end
PB.default_values(::Type{Span}) = (;trace_id = UInt8[], span_id = UInt8[], trace_state = "", parent_span_id = UInt8[], name = "", kind = var"Span.SpanKind".SPAN_KIND_UNSPECIFIED, start_time_unix_nano = zero(UInt64), end_time_unix_nano = zero(UInt64), attributes = Vector{opentelemetry.proto.common.v1.KeyValue}(), dropped_attributes_count = zero(UInt32), events = Vector{var"Span.Event"}(), dropped_events_count = zero(UInt32), links = Vector{var"Span.Link"}(), dropped_links_count = zero(UInt32), status = nothing)
PB.field_numbers(::Type{Span}) = (;trace_id = 1, span_id = 2, trace_state = 3, parent_span_id = 4, name = 5, kind = 6, start_time_unix_nano = 7, end_time_unix_nano = 8, attributes = 9, dropped_attributes_count = 10, events = 11, dropped_events_count = 12, links = 13, dropped_links_count = 14, status = 15)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Span})
    trace_id = UInt8[]
    span_id = UInt8[]
    trace_state = ""
    parent_span_id = UInt8[]
    name = ""
    kind = var"Span.SpanKind".SPAN_KIND_UNSPECIFIED
    start_time_unix_nano = zero(UInt64)
    end_time_unix_nano = zero(UInt64)
    attributes = PB.BufferedVector{opentelemetry.proto.common.v1.KeyValue}()
    dropped_attributes_count = zero(UInt32)
    events = PB.BufferedVector{var"Span.Event"}()
    dropped_events_count = zero(UInt32)
    links = PB.BufferedVector{var"Span.Link"}()
    dropped_links_count = zero(UInt32)
    status = Ref{Union{Nothing,Status}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            trace_id = PB.decode(d, Vector{UInt8})
        elseif field_number == 2
            span_id = PB.decode(d, Vector{UInt8})
        elseif field_number == 3
            trace_state = PB.decode(d, String)
        elseif field_number == 4
            parent_span_id = PB.decode(d, Vector{UInt8})
        elseif field_number == 5
            name = PB.decode(d, String)
        elseif field_number == 6
            kind = PB.decode(d, var"Span.SpanKind".T)
        elseif field_number == 7
            start_time_unix_nano = PB.decode(d, UInt64, Val{:fixed})
        elseif field_number == 8
            end_time_unix_nano = PB.decode(d, UInt64, Val{:fixed})
        elseif field_number == 9
            PB.decode!(d, attributes)
        elseif field_number == 10
            dropped_attributes_count = PB.decode(d, UInt32)
        elseif field_number == 11
            PB.decode!(d, events)
        elseif field_number == 12
            dropped_events_count = PB.decode(d, UInt32)
        elseif field_number == 13
            PB.decode!(d, links)
        elseif field_number == 14
            dropped_links_count = PB.decode(d, UInt32)
        elseif field_number == 15
            PB.decode!(d, status)
        else
            PB.skip(d, wire_type)
        end
    end
    return Span(trace_id, span_id, trace_state, parent_span_id, name, kind, start_time_unix_nano, end_time_unix_nano, attributes[], dropped_attributes_count, events[], dropped_events_count, links[], dropped_links_count, status)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Span)
    initpos = position(e.io)
    !isempty(x.trace_id) && PB.encode(e, 1, x.trace_id)
    !isempty(x.span_id) && PB.encode(e, 2, x.span_id)
    !isempty(x.trace_state) && PB.encode(e, 3, x.trace_state)
    !isempty(x.parent_span_id) && PB.encode(e, 4, x.parent_span_id)
    !isempty(x.name) && PB.encode(e, 5, x.name)
    x.kind != var"Span.SpanKind".SPAN_KIND_UNSPECIFIED && PB.encode(e, 6, x.kind)
    x.start_time_unix_nano != zero(UInt64) && PB.encode(e, 7, x.start_time_unix_nano, Val{:fixed})
    x.end_time_unix_nano != zero(UInt64) && PB.encode(e, 8, x.end_time_unix_nano, Val{:fixed})
    !isempty(x.attributes) && PB.encode(e, 9, x.attributes)
    x.dropped_attributes_count != zero(UInt32) && PB.encode(e, 10, x.dropped_attributes_count)
    !isempty(x.events) && PB.encode(e, 11, x.events)
    x.dropped_events_count != zero(UInt32) && PB.encode(e, 12, x.dropped_events_count)
    !isempty(x.links) && PB.encode(e, 13, x.links)
    x.dropped_links_count != zero(UInt32) && PB.encode(e, 14, x.dropped_links_count)
    !isnothing(x.status) && PB.encode(e, 15, x.status)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Span)
    encoded_size = 0
    !isempty(x.trace_id) && (encoded_size += PB._encoded_size(x.trace_id, 1))
    !isempty(x.span_id) && (encoded_size += PB._encoded_size(x.span_id, 2))
    !isempty(x.trace_state) && (encoded_size += PB._encoded_size(x.trace_state, 3))
    !isempty(x.parent_span_id) && (encoded_size += PB._encoded_size(x.parent_span_id, 4))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 5))
    x.kind != var"Span.SpanKind".SPAN_KIND_UNSPECIFIED && (encoded_size += PB._encoded_size(x.kind, 6))
    x.start_time_unix_nano != zero(UInt64) && (encoded_size += PB._encoded_size(x.start_time_unix_nano, 7, Val{:fixed}))
    x.end_time_unix_nano != zero(UInt64) && (encoded_size += PB._encoded_size(x.end_time_unix_nano, 8, Val{:fixed}))
    !isempty(x.attributes) && (encoded_size += PB._encoded_size(x.attributes, 9))
    x.dropped_attributes_count != zero(UInt32) && (encoded_size += PB._encoded_size(x.dropped_attributes_count, 10))
    !isempty(x.events) && (encoded_size += PB._encoded_size(x.events, 11))
    x.dropped_events_count != zero(UInt32) && (encoded_size += PB._encoded_size(x.dropped_events_count, 12))
    !isempty(x.links) && (encoded_size += PB._encoded_size(x.links, 13))
    x.dropped_links_count != zero(UInt32) && (encoded_size += PB._encoded_size(x.dropped_links_count, 14))
    !isnothing(x.status) && (encoded_size += PB._encoded_size(x.status, 15))
    return encoded_size
end

struct ScopeSpans
    scope::Union{Nothing,opentelemetry.proto.common.v1.InstrumentationScope}
    spans::Vector{Span}
    schema_url::String
end
PB.default_values(::Type{ScopeSpans}) = (;scope = nothing, spans = Vector{Span}(), schema_url = "")
PB.field_numbers(::Type{ScopeSpans}) = (;scope = 1, spans = 2, schema_url = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ScopeSpans})
    scope = Ref{Union{Nothing,opentelemetry.proto.common.v1.InstrumentationScope}}(nothing)
    spans = PB.BufferedVector{Span}()
    schema_url = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, scope)
        elseif field_number == 2
            PB.decode!(d, spans)
        elseif field_number == 3
            schema_url = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return ScopeSpans(scope[], spans[], schema_url)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ScopeSpans)
    initpos = position(e.io)
    !isnothing(x.scope) && PB.encode(e, 1, x.scope)
    !isempty(x.spans) && PB.encode(e, 2, x.spans)
    !isempty(x.schema_url) && PB.encode(e, 3, x.schema_url)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ScopeSpans)
    encoded_size = 0
    !isnothing(x.scope) && (encoded_size += PB._encoded_size(x.scope, 1))
    !isempty(x.spans) && (encoded_size += PB._encoded_size(x.spans, 2))
    !isempty(x.schema_url) && (encoded_size += PB._encoded_size(x.schema_url, 3))
    return encoded_size
end

struct ResourceSpans
    resource::Union{Nothing,opentelemetry.proto.resource.v1.Resource}
    scope_spans::Vector{ScopeSpans}
    schema_url::String
end
PB.reserved_fields(::Type{ResourceSpans}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[1000])
PB.default_values(::Type{ResourceSpans}) = (;resource = nothing, scope_spans = Vector{ScopeSpans}(), schema_url = "")
PB.field_numbers(::Type{ResourceSpans}) = (;resource = 1, scope_spans = 2, schema_url = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ResourceSpans})
    resource = Ref{Union{Nothing,opentelemetry.proto.resource.v1.Resource}}(nothing)
    scope_spans = PB.BufferedVector{ScopeSpans}()
    schema_url = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, resource)
        elseif field_number == 2
            PB.decode!(d, scope_spans)
        elseif field_number == 3
            schema_url = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return ResourceSpans(resource[], scope_spans[], schema_url)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ResourceSpans)
    initpos = position(e.io)
    !isnothing(x.resource) && PB.encode(e, 1, x.resource)
    !isempty(x.scope_spans) && PB.encode(e, 2, x.scope_spans)
    !isempty(x.schema_url) && PB.encode(e, 3, x.schema_url)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ResourceSpans)
    encoded_size = 0
    !isnothing(x.resource) && (encoded_size += PB._encoded_size(x.resource, 1))
    !isempty(x.scope_spans) && (encoded_size += PB._encoded_size(x.scope_spans, 2))
    !isempty(x.schema_url) && (encoded_size += PB._encoded_size(x.schema_url, 3))
    return encoded_size
end

struct TracesData
    resource_spans::Vector{ResourceSpans}
end
PB.default_values(::Type{TracesData}) = (;resource_spans = Vector{ResourceSpans}())
PB.field_numbers(::Type{TracesData}) = (;resource_spans = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TracesData})
    resource_spans = PB.BufferedVector{ResourceSpans}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, resource_spans)
        else
            PB.skip(d, wire_type)
        end
    end
    return TracesData(resource_spans[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TracesData)
    initpos = position(e.io)
    !isempty(x.resource_spans) && PB.encode(e, 1, x.resource_spans)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TracesData)
    encoded_size = 0
    !isempty(x.resource_spans) && (encoded_size += PB._encoded_size(x.resource_spans, 1))
    return encoded_size
end
