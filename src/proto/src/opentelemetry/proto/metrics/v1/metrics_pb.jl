# Autogenerated using ProtoBuf.jl v1.0.9 on 2023-03-01T12:24:35.952
# original file: /home/tj/workspace/git/OpenTelemetry.jl/src/proto/dev/opentelemetry-proto-0.19.0/opentelemetry/proto/metrics/v1/metrics.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export Exemplar, DataPointFlags, AggregationTemporality
export var"ExponentialHistogramDataPoint.Buckets", var"SummaryDataPoint.ValueAtQuantile"
export NumberDataPoint, HistogramDataPoint, ExponentialHistogramDataPoint, SummaryDataPoint
export Gauge, Sum, Histogram, ExponentialHistogram, Summary, Metric, ScopeMetrics
export ResourceMetrics, MetricsData

struct Exemplar
    filtered_attributes::Vector{opentelemetry.proto.common.v1.KeyValue}
    time_unix_nano::UInt64
    value::Union{Nothing,OneOf{<:Union{Float64,Int64}}}
    span_id::Vector{UInt8}
    trace_id::Vector{UInt8}
end
PB.reserved_fields(::Type{Exemplar}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[1])
PB.oneof_field_types(::Type{Exemplar}) = (;
    value = (;as_double=Float64, as_int=Int64),
)
PB.default_values(::Type{Exemplar}) = (;filtered_attributes = Vector{opentelemetry.proto.common.v1.KeyValue}(), time_unix_nano = zero(UInt64), as_double = zero(Float64), as_int = zero(Int64), span_id = UInt8[], trace_id = UInt8[])
PB.field_numbers(::Type{Exemplar}) = (;filtered_attributes = 7, time_unix_nano = 2, as_double = 3, as_int = 6, span_id = 4, trace_id = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Exemplar})
    filtered_attributes = PB.BufferedVector{opentelemetry.proto.common.v1.KeyValue}()
    time_unix_nano = zero(UInt64)
    value = nothing
    span_id = UInt8[]
    trace_id = UInt8[]
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 7
            PB.decode!(d, filtered_attributes)
        elseif field_number == 2
            time_unix_nano = PB.decode(d, UInt64, Val{:fixed})
        elseif field_number == 3
            value = OneOf(:as_double, PB.decode(d, Float64))
        elseif field_number == 6
            value = OneOf(:as_int, PB.decode(d, Int64, Val{:fixed}))
        elseif field_number == 4
            span_id = PB.decode(d, Vector{UInt8})
        elseif field_number == 5
            trace_id = PB.decode(d, Vector{UInt8})
        else
            PB.skip(d, wire_type)
        end
    end
    return Exemplar(filtered_attributes[], time_unix_nano, value, span_id, trace_id)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Exemplar)
    initpos = position(e.io)
    !isempty(x.filtered_attributes) && PB.encode(e, 7, x.filtered_attributes)
    x.time_unix_nano != zero(UInt64) && PB.encode(e, 2, x.time_unix_nano, Val{:fixed})
    if isnothing(x.value);
    elseif x.value.name === :as_double
        PB.encode(e, 3, x.value[]::Float64)
    elseif x.value.name === :as_int
        PB.encode(e, 6, x.value[]::Int64, Val{:fixed})
    end
    !isempty(x.span_id) && PB.encode(e, 4, x.span_id)
    !isempty(x.trace_id) && PB.encode(e, 5, x.trace_id)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Exemplar)
    encoded_size = 0
    !isempty(x.filtered_attributes) && (encoded_size += PB._encoded_size(x.filtered_attributes, 7))
    x.time_unix_nano != zero(UInt64) && (encoded_size += PB._encoded_size(x.time_unix_nano, 2, Val{:fixed}))
    if isnothing(x.value);
    elseif x.value.name === :as_double
        encoded_size += PB._encoded_size(x.value[]::Float64, 3)
    elseif x.value.name === :as_int
        encoded_size += PB._encoded_size(x.value[]::Int64, 6, Val{:fixed})
    end
    !isempty(x.span_id) && (encoded_size += PB._encoded_size(x.span_id, 4))
    !isempty(x.trace_id) && (encoded_size += PB._encoded_size(x.trace_id, 5))
    return encoded_size
end

@enumx DataPointFlags FLAG_NONE=0 FLAG_NO_RECORDED_VALUE=1

@enumx AggregationTemporality AGGREGATION_TEMPORALITY_UNSPECIFIED=0 AGGREGATION_TEMPORALITY_DELTA=1 AGGREGATION_TEMPORALITY_CUMULATIVE=2

struct var"ExponentialHistogramDataPoint.Buckets"
    offset::Int32
    bucket_counts::Vector{UInt64}
end
PB.default_values(::Type{var"ExponentialHistogramDataPoint.Buckets"}) = (;offset = zero(Int32), bucket_counts = Vector{UInt64}())
PB.field_numbers(::Type{var"ExponentialHistogramDataPoint.Buckets"}) = (;offset = 1, bucket_counts = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"ExponentialHistogramDataPoint.Buckets"})
    offset = zero(Int32)
    bucket_counts = PB.BufferedVector{UInt64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            offset = PB.decode(d, Int32, Val{:zigzag})
        elseif field_number == 2
            PB.decode!(d, wire_type, bucket_counts)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"ExponentialHistogramDataPoint.Buckets"(offset, bucket_counts[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"ExponentialHistogramDataPoint.Buckets")
    initpos = position(e.io)
    x.offset != zero(Int32) && PB.encode(e, 1, x.offset, Val{:zigzag})
    !isempty(x.bucket_counts) && PB.encode(e, 2, x.bucket_counts)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"ExponentialHistogramDataPoint.Buckets")
    encoded_size = 0
    x.offset != zero(Int32) && (encoded_size += PB._encoded_size(x.offset, 1, Val{:zigzag}))
    !isempty(x.bucket_counts) && (encoded_size += PB._encoded_size(x.bucket_counts, 2))
    return encoded_size
end

struct var"SummaryDataPoint.ValueAtQuantile"
    quantile::Float64
    value::Float64
end
PB.default_values(::Type{var"SummaryDataPoint.ValueAtQuantile"}) = (;quantile = zero(Float64), value = zero(Float64))
PB.field_numbers(::Type{var"SummaryDataPoint.ValueAtQuantile"}) = (;quantile = 1, value = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"SummaryDataPoint.ValueAtQuantile"})
    quantile = zero(Float64)
    value = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            quantile = PB.decode(d, Float64)
        elseif field_number == 2
            value = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"SummaryDataPoint.ValueAtQuantile"(quantile, value)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"SummaryDataPoint.ValueAtQuantile")
    initpos = position(e.io)
    x.quantile != zero(Float64) && PB.encode(e, 1, x.quantile)
    x.value != zero(Float64) && PB.encode(e, 2, x.value)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"SummaryDataPoint.ValueAtQuantile")
    encoded_size = 0
    x.quantile != zero(Float64) && (encoded_size += PB._encoded_size(x.quantile, 1))
    x.value != zero(Float64) && (encoded_size += PB._encoded_size(x.value, 2))
    return encoded_size
end

struct NumberDataPoint
    attributes::Vector{opentelemetry.proto.common.v1.KeyValue}
    start_time_unix_nano::UInt64
    time_unix_nano::UInt64
    value::Union{Nothing,OneOf{<:Union{Float64,Int64}}}
    exemplars::Vector{Exemplar}
    flags::UInt32
end
PB.reserved_fields(::Type{NumberDataPoint}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[1])
PB.oneof_field_types(::Type{NumberDataPoint}) = (;
    value = (;as_double=Float64, as_int=Int64),
)
PB.default_values(::Type{NumberDataPoint}) = (;attributes = Vector{opentelemetry.proto.common.v1.KeyValue}(), start_time_unix_nano = zero(UInt64), time_unix_nano = zero(UInt64), as_double = zero(Float64), as_int = zero(Int64), exemplars = Vector{Exemplar}(), flags = zero(UInt32))
PB.field_numbers(::Type{NumberDataPoint}) = (;attributes = 7, start_time_unix_nano = 2, time_unix_nano = 3, as_double = 4, as_int = 6, exemplars = 5, flags = 8)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:NumberDataPoint})
    attributes = PB.BufferedVector{opentelemetry.proto.common.v1.KeyValue}()
    start_time_unix_nano = zero(UInt64)
    time_unix_nano = zero(UInt64)
    value = nothing
    exemplars = PB.BufferedVector{Exemplar}()
    flags = zero(UInt32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 7
            PB.decode!(d, attributes)
        elseif field_number == 2
            start_time_unix_nano = PB.decode(d, UInt64, Val{:fixed})
        elseif field_number == 3
            time_unix_nano = PB.decode(d, UInt64, Val{:fixed})
        elseif field_number == 4
            value = OneOf(:as_double, PB.decode(d, Float64))
        elseif field_number == 6
            value = OneOf(:as_int, PB.decode(d, Int64, Val{:fixed}))
        elseif field_number == 5
            PB.decode!(d, exemplars)
        elseif field_number == 8
            flags = PB.decode(d, UInt32)
        else
            PB.skip(d, wire_type)
        end
    end
    return NumberDataPoint(attributes[], start_time_unix_nano, time_unix_nano, value, exemplars[], flags)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::NumberDataPoint)
    initpos = position(e.io)
    !isempty(x.attributes) && PB.encode(e, 7, x.attributes)
    x.start_time_unix_nano != zero(UInt64) && PB.encode(e, 2, x.start_time_unix_nano, Val{:fixed})
    x.time_unix_nano != zero(UInt64) && PB.encode(e, 3, x.time_unix_nano, Val{:fixed})
    if isnothing(x.value);
    elseif x.value.name === :as_double
        PB.encode(e, 4, x.value[]::Float64)
    elseif x.value.name === :as_int
        PB.encode(e, 6, x.value[]::Int64, Val{:fixed})
    end
    !isempty(x.exemplars) && PB.encode(e, 5, x.exemplars)
    x.flags != zero(UInt32) && PB.encode(e, 8, x.flags)
    return position(e.io) - initpos
end
function PB._encoded_size(x::NumberDataPoint)
    encoded_size = 0
    !isempty(x.attributes) && (encoded_size += PB._encoded_size(x.attributes, 7))
    x.start_time_unix_nano != zero(UInt64) && (encoded_size += PB._encoded_size(x.start_time_unix_nano, 2, Val{:fixed}))
    x.time_unix_nano != zero(UInt64) && (encoded_size += PB._encoded_size(x.time_unix_nano, 3, Val{:fixed}))
    if isnothing(x.value);
    elseif x.value.name === :as_double
        encoded_size += PB._encoded_size(x.value[]::Float64, 4)
    elseif x.value.name === :as_int
        encoded_size += PB._encoded_size(x.value[]::Int64, 6, Val{:fixed})
    end
    !isempty(x.exemplars) && (encoded_size += PB._encoded_size(x.exemplars, 5))
    x.flags != zero(UInt32) && (encoded_size += PB._encoded_size(x.flags, 8))
    return encoded_size
end

struct HistogramDataPoint
    attributes::Vector{opentelemetry.proto.common.v1.KeyValue}
    start_time_unix_nano::UInt64
    time_unix_nano::UInt64
    count::UInt64
    sum::Float64
    bucket_counts::Vector{UInt64}
    explicit_bounds::Vector{Float64}
    exemplars::Vector{Exemplar}
    flags::UInt32
    min::Float64
    max::Float64
end
PB.reserved_fields(::Type{HistogramDataPoint}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[1])
PB.default_values(::Type{HistogramDataPoint}) = (;attributes = Vector{opentelemetry.proto.common.v1.KeyValue}(), start_time_unix_nano = zero(UInt64), time_unix_nano = zero(UInt64), count = zero(UInt64), sum = zero(Float64), bucket_counts = Vector{UInt64}(), explicit_bounds = Vector{Float64}(), exemplars = Vector{Exemplar}(), flags = zero(UInt32), min = zero(Float64), max = zero(Float64))
PB.field_numbers(::Type{HistogramDataPoint}) = (;attributes = 9, start_time_unix_nano = 2, time_unix_nano = 3, count = 4, sum = 5, bucket_counts = 6, explicit_bounds = 7, exemplars = 8, flags = 10, min = 11, max = 12)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:HistogramDataPoint})
    attributes = PB.BufferedVector{opentelemetry.proto.common.v1.KeyValue}()
    start_time_unix_nano = zero(UInt64)
    time_unix_nano = zero(UInt64)
    count = zero(UInt64)
    sum = zero(Float64)
    bucket_counts = PB.BufferedVector{UInt64}()
    explicit_bounds = PB.BufferedVector{Float64}()
    exemplars = PB.BufferedVector{Exemplar}()
    flags = zero(UInt32)
    min = zero(Float64)
    max = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 9
            PB.decode!(d, attributes)
        elseif field_number == 2
            start_time_unix_nano = PB.decode(d, UInt64, Val{:fixed})
        elseif field_number == 3
            time_unix_nano = PB.decode(d, UInt64, Val{:fixed})
        elseif field_number == 4
            count = PB.decode(d, UInt64, Val{:fixed})
        elseif field_number == 5
            sum = PB.decode(d, Float64)
        elseif field_number == 6
            PB.decode!(d, wire_type, bucket_counts, Val{:fixed})
        elseif field_number == 7
            PB.decode!(d, wire_type, explicit_bounds)
        elseif field_number == 8
            PB.decode!(d, exemplars)
        elseif field_number == 10
            flags = PB.decode(d, UInt32)
        elseif field_number == 11
            min = PB.decode(d, Float64)
        elseif field_number == 12
            max = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return HistogramDataPoint(attributes[], start_time_unix_nano, time_unix_nano, count, sum, bucket_counts[], explicit_bounds[], exemplars[], flags, min, max)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::HistogramDataPoint)
    initpos = position(e.io)
    !isempty(x.attributes) && PB.encode(e, 9, x.attributes)
    x.start_time_unix_nano != zero(UInt64) && PB.encode(e, 2, x.start_time_unix_nano, Val{:fixed})
    x.time_unix_nano != zero(UInt64) && PB.encode(e, 3, x.time_unix_nano, Val{:fixed})
    x.count != zero(UInt64) && PB.encode(e, 4, x.count, Val{:fixed})
    x.sum != zero(Float64) && PB.encode(e, 5, x.sum)
    !isempty(x.bucket_counts) && PB.encode(e, 6, x.bucket_counts, Val{:fixed})
    !isempty(x.explicit_bounds) && PB.encode(e, 7, x.explicit_bounds)
    !isempty(x.exemplars) && PB.encode(e, 8, x.exemplars)
    x.flags != zero(UInt32) && PB.encode(e, 10, x.flags)
    x.min != zero(Float64) && PB.encode(e, 11, x.min)
    x.max != zero(Float64) && PB.encode(e, 12, x.max)
    return position(e.io) - initpos
end
function PB._encoded_size(x::HistogramDataPoint)
    encoded_size = 0
    !isempty(x.attributes) && (encoded_size += PB._encoded_size(x.attributes, 9))
    x.start_time_unix_nano != zero(UInt64) && (encoded_size += PB._encoded_size(x.start_time_unix_nano, 2, Val{:fixed}))
    x.time_unix_nano != zero(UInt64) && (encoded_size += PB._encoded_size(x.time_unix_nano, 3, Val{:fixed}))
    x.count != zero(UInt64) && (encoded_size += PB._encoded_size(x.count, 4, Val{:fixed}))
    x.sum != zero(Float64) && (encoded_size += PB._encoded_size(x.sum, 5))
    !isempty(x.bucket_counts) && (encoded_size += PB._encoded_size(x.bucket_counts, 6, Val{:fixed}))
    !isempty(x.explicit_bounds) && (encoded_size += PB._encoded_size(x.explicit_bounds, 7))
    !isempty(x.exemplars) && (encoded_size += PB._encoded_size(x.exemplars, 8))
    x.flags != zero(UInt32) && (encoded_size += PB._encoded_size(x.flags, 10))
    x.min != zero(Float64) && (encoded_size += PB._encoded_size(x.min, 11))
    x.max != zero(Float64) && (encoded_size += PB._encoded_size(x.max, 12))
    return encoded_size
end

struct ExponentialHistogramDataPoint
    attributes::Vector{opentelemetry.proto.common.v1.KeyValue}
    start_time_unix_nano::UInt64
    time_unix_nano::UInt64
    count::UInt64
    sum::Float64
    scale::Int32
    zero_count::UInt64
    positive::Union{Nothing,var"ExponentialHistogramDataPoint.Buckets"}
    negative::Union{Nothing,var"ExponentialHistogramDataPoint.Buckets"}
    flags::UInt32
    exemplars::Vector{Exemplar}
    min::Float64
    max::Float64
end
PB.default_values(::Type{ExponentialHistogramDataPoint}) = (;attributes = Vector{opentelemetry.proto.common.v1.KeyValue}(), start_time_unix_nano = zero(UInt64), time_unix_nano = zero(UInt64), count = zero(UInt64), sum = zero(Float64), scale = zero(Int32), zero_count = zero(UInt64), positive = nothing, negative = nothing, flags = zero(UInt32), exemplars = Vector{Exemplar}(), min = zero(Float64), max = zero(Float64))
PB.field_numbers(::Type{ExponentialHistogramDataPoint}) = (;attributes = 1, start_time_unix_nano = 2, time_unix_nano = 3, count = 4, sum = 5, scale = 6, zero_count = 7, positive = 8, negative = 9, flags = 10, exemplars = 11, min = 12, max = 13)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ExponentialHistogramDataPoint})
    attributes = PB.BufferedVector{opentelemetry.proto.common.v1.KeyValue}()
    start_time_unix_nano = zero(UInt64)
    time_unix_nano = zero(UInt64)
    count = zero(UInt64)
    sum = zero(Float64)
    scale = zero(Int32)
    zero_count = zero(UInt64)
    positive = Ref{Union{Nothing,var"ExponentialHistogramDataPoint.Buckets"}}(nothing)
    negative = Ref{Union{Nothing,var"ExponentialHistogramDataPoint.Buckets"}}(nothing)
    flags = zero(UInt32)
    exemplars = PB.BufferedVector{Exemplar}()
    min = zero(Float64)
    max = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, attributes)
        elseif field_number == 2
            start_time_unix_nano = PB.decode(d, UInt64, Val{:fixed})
        elseif field_number == 3
            time_unix_nano = PB.decode(d, UInt64, Val{:fixed})
        elseif field_number == 4
            count = PB.decode(d, UInt64, Val{:fixed})
        elseif field_number == 5
            sum = PB.decode(d, Float64)
        elseif field_number == 6
            scale = PB.decode(d, Int32, Val{:zigzag})
        elseif field_number == 7
            zero_count = PB.decode(d, UInt64, Val{:fixed})
        elseif field_number == 8
            PB.decode!(d, positive)
        elseif field_number == 9
            PB.decode!(d, negative)
        elseif field_number == 10
            flags = PB.decode(d, UInt32)
        elseif field_number == 11
            PB.decode!(d, exemplars)
        elseif field_number == 12
            min = PB.decode(d, Float64)
        elseif field_number == 13
            max = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return ExponentialHistogramDataPoint(attributes[], start_time_unix_nano, time_unix_nano, count, sum, scale, zero_count, positive[], negative[], flags, exemplars[], min, max)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ExponentialHistogramDataPoint)
    initpos = position(e.io)
    !isempty(x.attributes) && PB.encode(e, 1, x.attributes)
    x.start_time_unix_nano != zero(UInt64) && PB.encode(e, 2, x.start_time_unix_nano, Val{:fixed})
    x.time_unix_nano != zero(UInt64) && PB.encode(e, 3, x.time_unix_nano, Val{:fixed})
    x.count != zero(UInt64) && PB.encode(e, 4, x.count, Val{:fixed})
    x.sum != zero(Float64) && PB.encode(e, 5, x.sum)
    x.scale != zero(Int32) && PB.encode(e, 6, x.scale, Val{:zigzag})
    x.zero_count != zero(UInt64) && PB.encode(e, 7, x.zero_count, Val{:fixed})
    !isnothing(x.positive) && PB.encode(e, 8, x.positive)
    !isnothing(x.negative) && PB.encode(e, 9, x.negative)
    x.flags != zero(UInt32) && PB.encode(e, 10, x.flags)
    !isempty(x.exemplars) && PB.encode(e, 11, x.exemplars)
    x.min != zero(Float64) && PB.encode(e, 12, x.min)
    x.max != zero(Float64) && PB.encode(e, 13, x.max)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ExponentialHistogramDataPoint)
    encoded_size = 0
    !isempty(x.attributes) && (encoded_size += PB._encoded_size(x.attributes, 1))
    x.start_time_unix_nano != zero(UInt64) && (encoded_size += PB._encoded_size(x.start_time_unix_nano, 2, Val{:fixed}))
    x.time_unix_nano != zero(UInt64) && (encoded_size += PB._encoded_size(x.time_unix_nano, 3, Val{:fixed}))
    x.count != zero(UInt64) && (encoded_size += PB._encoded_size(x.count, 4, Val{:fixed}))
    x.sum != zero(Float64) && (encoded_size += PB._encoded_size(x.sum, 5))
    x.scale != zero(Int32) && (encoded_size += PB._encoded_size(x.scale, 6, Val{:zigzag}))
    x.zero_count != zero(UInt64) && (encoded_size += PB._encoded_size(x.zero_count, 7, Val{:fixed}))
    !isnothing(x.positive) && (encoded_size += PB._encoded_size(x.positive, 8))
    !isnothing(x.negative) && (encoded_size += PB._encoded_size(x.negative, 9))
    x.flags != zero(UInt32) && (encoded_size += PB._encoded_size(x.flags, 10))
    !isempty(x.exemplars) && (encoded_size += PB._encoded_size(x.exemplars, 11))
    x.min != zero(Float64) && (encoded_size += PB._encoded_size(x.min, 12))
    x.max != zero(Float64) && (encoded_size += PB._encoded_size(x.max, 13))
    return encoded_size
end

struct SummaryDataPoint
    attributes::Vector{opentelemetry.proto.common.v1.KeyValue}
    start_time_unix_nano::UInt64
    time_unix_nano::UInt64
    count::UInt64
    sum::Float64
    quantile_values::Vector{var"SummaryDataPoint.ValueAtQuantile"}
    flags::UInt32
end
PB.reserved_fields(::Type{SummaryDataPoint}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[1])
PB.default_values(::Type{SummaryDataPoint}) = (;attributes = Vector{opentelemetry.proto.common.v1.KeyValue}(), start_time_unix_nano = zero(UInt64), time_unix_nano = zero(UInt64), count = zero(UInt64), sum = zero(Float64), quantile_values = Vector{var"SummaryDataPoint.ValueAtQuantile"}(), flags = zero(UInt32))
PB.field_numbers(::Type{SummaryDataPoint}) = (;attributes = 7, start_time_unix_nano = 2, time_unix_nano = 3, count = 4, sum = 5, quantile_values = 6, flags = 8)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SummaryDataPoint})
    attributes = PB.BufferedVector{opentelemetry.proto.common.v1.KeyValue}()
    start_time_unix_nano = zero(UInt64)
    time_unix_nano = zero(UInt64)
    count = zero(UInt64)
    sum = zero(Float64)
    quantile_values = PB.BufferedVector{var"SummaryDataPoint.ValueAtQuantile"}()
    flags = zero(UInt32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 7
            PB.decode!(d, attributes)
        elseif field_number == 2
            start_time_unix_nano = PB.decode(d, UInt64, Val{:fixed})
        elseif field_number == 3
            time_unix_nano = PB.decode(d, UInt64, Val{:fixed})
        elseif field_number == 4
            count = PB.decode(d, UInt64, Val{:fixed})
        elseif field_number == 5
            sum = PB.decode(d, Float64)
        elseif field_number == 6
            PB.decode!(d, quantile_values)
        elseif field_number == 8
            flags = PB.decode(d, UInt32)
        else
            PB.skip(d, wire_type)
        end
    end
    return SummaryDataPoint(attributes[], start_time_unix_nano, time_unix_nano, count, sum, quantile_values[], flags)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SummaryDataPoint)
    initpos = position(e.io)
    !isempty(x.attributes) && PB.encode(e, 7, x.attributes)
    x.start_time_unix_nano != zero(UInt64) && PB.encode(e, 2, x.start_time_unix_nano, Val{:fixed})
    x.time_unix_nano != zero(UInt64) && PB.encode(e, 3, x.time_unix_nano, Val{:fixed})
    x.count != zero(UInt64) && PB.encode(e, 4, x.count, Val{:fixed})
    x.sum != zero(Float64) && PB.encode(e, 5, x.sum)
    !isempty(x.quantile_values) && PB.encode(e, 6, x.quantile_values)
    x.flags != zero(UInt32) && PB.encode(e, 8, x.flags)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SummaryDataPoint)
    encoded_size = 0
    !isempty(x.attributes) && (encoded_size += PB._encoded_size(x.attributes, 7))
    x.start_time_unix_nano != zero(UInt64) && (encoded_size += PB._encoded_size(x.start_time_unix_nano, 2, Val{:fixed}))
    x.time_unix_nano != zero(UInt64) && (encoded_size += PB._encoded_size(x.time_unix_nano, 3, Val{:fixed}))
    x.count != zero(UInt64) && (encoded_size += PB._encoded_size(x.count, 4, Val{:fixed}))
    x.sum != zero(Float64) && (encoded_size += PB._encoded_size(x.sum, 5))
    !isempty(x.quantile_values) && (encoded_size += PB._encoded_size(x.quantile_values, 6))
    x.flags != zero(UInt32) && (encoded_size += PB._encoded_size(x.flags, 8))
    return encoded_size
end

struct Gauge
    data_points::Vector{NumberDataPoint}
end
PB.default_values(::Type{Gauge}) = (;data_points = Vector{NumberDataPoint}())
PB.field_numbers(::Type{Gauge}) = (;data_points = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Gauge})
    data_points = PB.BufferedVector{NumberDataPoint}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, data_points)
        else
            PB.skip(d, wire_type)
        end
    end
    return Gauge(data_points[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Gauge)
    initpos = position(e.io)
    !isempty(x.data_points) && PB.encode(e, 1, x.data_points)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Gauge)
    encoded_size = 0
    !isempty(x.data_points) && (encoded_size += PB._encoded_size(x.data_points, 1))
    return encoded_size
end

struct Sum
    data_points::Vector{NumberDataPoint}
    aggregation_temporality::AggregationTemporality.T
    is_monotonic::Bool
end
PB.default_values(::Type{Sum}) = (;data_points = Vector{NumberDataPoint}(), aggregation_temporality = AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED, is_monotonic = false)
PB.field_numbers(::Type{Sum}) = (;data_points = 1, aggregation_temporality = 2, is_monotonic = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Sum})
    data_points = PB.BufferedVector{NumberDataPoint}()
    aggregation_temporality = AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED
    is_monotonic = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, data_points)
        elseif field_number == 2
            aggregation_temporality = PB.decode(d, AggregationTemporality.T)
        elseif field_number == 3
            is_monotonic = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return Sum(data_points[], aggregation_temporality, is_monotonic)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Sum)
    initpos = position(e.io)
    !isempty(x.data_points) && PB.encode(e, 1, x.data_points)
    x.aggregation_temporality != AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED && PB.encode(e, 2, x.aggregation_temporality)
    x.is_monotonic != false && PB.encode(e, 3, x.is_monotonic)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Sum)
    encoded_size = 0
    !isempty(x.data_points) && (encoded_size += PB._encoded_size(x.data_points, 1))
    x.aggregation_temporality != AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED && (encoded_size += PB._encoded_size(x.aggregation_temporality, 2))
    x.is_monotonic != false && (encoded_size += PB._encoded_size(x.is_monotonic, 3))
    return encoded_size
end

struct Histogram
    data_points::Vector{HistogramDataPoint}
    aggregation_temporality::AggregationTemporality.T
end
PB.default_values(::Type{Histogram}) = (;data_points = Vector{HistogramDataPoint}(), aggregation_temporality = AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED)
PB.field_numbers(::Type{Histogram}) = (;data_points = 1, aggregation_temporality = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Histogram})
    data_points = PB.BufferedVector{HistogramDataPoint}()
    aggregation_temporality = AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, data_points)
        elseif field_number == 2
            aggregation_temporality = PB.decode(d, AggregationTemporality.T)
        else
            PB.skip(d, wire_type)
        end
    end
    return Histogram(data_points[], aggregation_temporality)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Histogram)
    initpos = position(e.io)
    !isempty(x.data_points) && PB.encode(e, 1, x.data_points)
    x.aggregation_temporality != AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED && PB.encode(e, 2, x.aggregation_temporality)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Histogram)
    encoded_size = 0
    !isempty(x.data_points) && (encoded_size += PB._encoded_size(x.data_points, 1))
    x.aggregation_temporality != AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED && (encoded_size += PB._encoded_size(x.aggregation_temporality, 2))
    return encoded_size
end

struct ExponentialHistogram
    data_points::Vector{ExponentialHistogramDataPoint}
    aggregation_temporality::AggregationTemporality.T
end
PB.default_values(::Type{ExponentialHistogram}) = (;data_points = Vector{ExponentialHistogramDataPoint}(), aggregation_temporality = AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED)
PB.field_numbers(::Type{ExponentialHistogram}) = (;data_points = 1, aggregation_temporality = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ExponentialHistogram})
    data_points = PB.BufferedVector{ExponentialHistogramDataPoint}()
    aggregation_temporality = AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, data_points)
        elseif field_number == 2
            aggregation_temporality = PB.decode(d, AggregationTemporality.T)
        else
            PB.skip(d, wire_type)
        end
    end
    return ExponentialHistogram(data_points[], aggregation_temporality)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ExponentialHistogram)
    initpos = position(e.io)
    !isempty(x.data_points) && PB.encode(e, 1, x.data_points)
    x.aggregation_temporality != AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED && PB.encode(e, 2, x.aggregation_temporality)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ExponentialHistogram)
    encoded_size = 0
    !isempty(x.data_points) && (encoded_size += PB._encoded_size(x.data_points, 1))
    x.aggregation_temporality != AggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED && (encoded_size += PB._encoded_size(x.aggregation_temporality, 2))
    return encoded_size
end

struct Summary
    data_points::Vector{SummaryDataPoint}
end
PB.default_values(::Type{Summary}) = (;data_points = Vector{SummaryDataPoint}())
PB.field_numbers(::Type{Summary}) = (;data_points = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Summary})
    data_points = PB.BufferedVector{SummaryDataPoint}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, data_points)
        else
            PB.skip(d, wire_type)
        end
    end
    return Summary(data_points[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Summary)
    initpos = position(e.io)
    !isempty(x.data_points) && PB.encode(e, 1, x.data_points)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Summary)
    encoded_size = 0
    !isempty(x.data_points) && (encoded_size += PB._encoded_size(x.data_points, 1))
    return encoded_size
end

struct Metric
    name::String
    description::String
    unit::String
    data::Union{Nothing,OneOf{<:Union{Gauge,Sum,Histogram,ExponentialHistogram,Summary}}}
end
PB.reserved_fields(::Type{Metric}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[4, 6, 8])
PB.oneof_field_types(::Type{Metric}) = (;
    data = (;gauge=Gauge, sum=Sum, histogram=Histogram, exponential_histogram=ExponentialHistogram, summary=Summary),
)
PB.default_values(::Type{Metric}) = (;name = "", description = "", unit = "", gauge = nothing, sum = nothing, histogram = nothing, exponential_histogram = nothing, summary = nothing)
PB.field_numbers(::Type{Metric}) = (;name = 1, description = 2, unit = 3, gauge = 5, sum = 7, histogram = 9, exponential_histogram = 10, summary = 11)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Metric})
    name = ""
    description = ""
    unit = ""
    data = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            description = PB.decode(d, String)
        elseif field_number == 3
            unit = PB.decode(d, String)
        elseif field_number == 5
            data = OneOf(:gauge, PB.decode(d, Ref{Gauge}))
        elseif field_number == 7
            data = OneOf(:sum, PB.decode(d, Ref{Sum}))
        elseif field_number == 9
            data = OneOf(:histogram, PB.decode(d, Ref{Histogram}))
        elseif field_number == 10
            data = OneOf(:exponential_histogram, PB.decode(d, Ref{ExponentialHistogram}))
        elseif field_number == 11
            data = OneOf(:summary, PB.decode(d, Ref{Summary}))
        else
            PB.skip(d, wire_type)
        end
    end
    return Metric(name, description, unit, data)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Metric)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.description) && PB.encode(e, 2, x.description)
    !isempty(x.unit) && PB.encode(e, 3, x.unit)
    if isnothing(x.data);
    elseif x.data.name === :gauge
        PB.encode(e, 5, x.data[]::Gauge)
    elseif x.data.name === :sum
        PB.encode(e, 7, x.data[]::Sum)
    elseif x.data.name === :histogram
        PB.encode(e, 9, x.data[]::Histogram)
    elseif x.data.name === :exponential_histogram
        PB.encode(e, 10, x.data[]::ExponentialHistogram)
    elseif x.data.name === :summary
        PB.encode(e, 11, x.data[]::Summary)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Metric)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.description) && (encoded_size += PB._encoded_size(x.description, 2))
    !isempty(x.unit) && (encoded_size += PB._encoded_size(x.unit, 3))
    if isnothing(x.data);
    elseif x.data.name === :gauge
        encoded_size += PB._encoded_size(x.data[]::Gauge, 5)
    elseif x.data.name === :sum
        encoded_size += PB._encoded_size(x.data[]::Sum, 7)
    elseif x.data.name === :histogram
        encoded_size += PB._encoded_size(x.data[]::Histogram, 9)
    elseif x.data.name === :exponential_histogram
        encoded_size += PB._encoded_size(x.data[]::ExponentialHistogram, 10)
    elseif x.data.name === :summary
        encoded_size += PB._encoded_size(x.data[]::Summary, 11)
    end
    return encoded_size
end

struct ScopeMetrics
    scope::Union{Nothing,opentelemetry.proto.common.v1.InstrumentationScope}
    metrics::Vector{Metric}
    schema_url::String
end
PB.default_values(::Type{ScopeMetrics}) = (;scope = nothing, metrics = Vector{Metric}(), schema_url = "")
PB.field_numbers(::Type{ScopeMetrics}) = (;scope = 1, metrics = 2, schema_url = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ScopeMetrics})
    scope = Ref{Union{Nothing,opentelemetry.proto.common.v1.InstrumentationScope}}(nothing)
    metrics = PB.BufferedVector{Metric}()
    schema_url = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, scope)
        elseif field_number == 2
            PB.decode!(d, metrics)
        elseif field_number == 3
            schema_url = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return ScopeMetrics(scope[], metrics[], schema_url)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ScopeMetrics)
    initpos = position(e.io)
    !isnothing(x.scope) && PB.encode(e, 1, x.scope)
    !isempty(x.metrics) && PB.encode(e, 2, x.metrics)
    !isempty(x.schema_url) && PB.encode(e, 3, x.schema_url)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ScopeMetrics)
    encoded_size = 0
    !isnothing(x.scope) && (encoded_size += PB._encoded_size(x.scope, 1))
    !isempty(x.metrics) && (encoded_size += PB._encoded_size(x.metrics, 2))
    !isempty(x.schema_url) && (encoded_size += PB._encoded_size(x.schema_url, 3))
    return encoded_size
end

struct ResourceMetrics
    resource::Union{Nothing,opentelemetry.proto.resource.v1.Resource}
    scope_metrics::Vector{ScopeMetrics}
    schema_url::String
end
PB.reserved_fields(::Type{ResourceMetrics}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[1000])
PB.default_values(::Type{ResourceMetrics}) = (;resource = nothing, scope_metrics = Vector{ScopeMetrics}(), schema_url = "")
PB.field_numbers(::Type{ResourceMetrics}) = (;resource = 1, scope_metrics = 2, schema_url = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ResourceMetrics})
    resource = Ref{Union{Nothing,opentelemetry.proto.resource.v1.Resource}}(nothing)
    scope_metrics = PB.BufferedVector{ScopeMetrics}()
    schema_url = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, resource)
        elseif field_number == 2
            PB.decode!(d, scope_metrics)
        elseif field_number == 3
            schema_url = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return ResourceMetrics(resource[], scope_metrics[], schema_url)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ResourceMetrics)
    initpos = position(e.io)
    !isnothing(x.resource) && PB.encode(e, 1, x.resource)
    !isempty(x.scope_metrics) && PB.encode(e, 2, x.scope_metrics)
    !isempty(x.schema_url) && PB.encode(e, 3, x.schema_url)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ResourceMetrics)
    encoded_size = 0
    !isnothing(x.resource) && (encoded_size += PB._encoded_size(x.resource, 1))
    !isempty(x.scope_metrics) && (encoded_size += PB._encoded_size(x.scope_metrics, 2))
    !isempty(x.schema_url) && (encoded_size += PB._encoded_size(x.schema_url, 3))
    return encoded_size
end

struct MetricsData
    resource_metrics::Vector{ResourceMetrics}
end
PB.default_values(::Type{MetricsData}) = (;resource_metrics = Vector{ResourceMetrics}())
PB.field_numbers(::Type{MetricsData}) = (;resource_metrics = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MetricsData})
    resource_metrics = PB.BufferedVector{ResourceMetrics}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, resource_metrics)
        else
            PB.skip(d, wire_type)
        end
    end
    return MetricsData(resource_metrics[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MetricsData)
    initpos = position(e.io)
    !isempty(x.resource_metrics) && PB.encode(e, 1, x.resource_metrics)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MetricsData)
    encoded_size = 0
    !isempty(x.resource_metrics) && (encoded_size += PB._encoded_size(x.resource_metrics, 1))
    return encoded_size
end
