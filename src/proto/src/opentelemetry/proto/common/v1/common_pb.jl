# Autogenerated using ProtoBuf.jl v1.0.9 on 2023-03-01T12:24:55.831
# original file: /home/tj/workspace/git/OpenTelemetry.jl/src/proto/dev/opentelemetry-proto-0.19.0/opentelemetry/proto/common/v1/common.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export ArrayValue, InstrumentationScope, KeyValueList, AnyValue, KeyValue

# Abstract types to help resolve mutually recursive definitions
abstract type var"##AbstractArrayValue" end
abstract type var"##AbstractInstrumentationScope" end
abstract type var"##AbstractKeyValueList" end
abstract type var"##AbstractAnyValue" end
abstract type var"##AbstractKeyValue" end


struct ArrayValue{T1<:Union{Nothing,var"##AbstractAnyValue"}} <: var"##AbstractArrayValue"
    values::Vector{T1}
end
PB.default_values(::Type{ArrayValue}) = (;values = Vector{AnyValue}())
PB.field_numbers(::Type{ArrayValue}) = (;values = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ArrayValue})
    values = PB.BufferedVector{AnyValue}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, values)
        else
            PB.skip(d, wire_type)
        end
    end
    return ArrayValue(values[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ArrayValue)
    initpos = position(e.io)
    !isempty(x.values) && PB.encode(e, 1, x.values)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ArrayValue)
    encoded_size = 0
    !isempty(x.values) && (encoded_size += PB._encoded_size(x.values, 1))
    return encoded_size
end

struct InstrumentationScope{T1<:Union{Nothing,var"##AbstractKeyValue"}} <: var"##AbstractInstrumentationScope"
    name::String
    version::String
    attributes::Vector{T1}
    dropped_attributes_count::UInt32
end
PB.default_values(::Type{InstrumentationScope}) = (;name = "", version = "", attributes = Vector{KeyValue}(), dropped_attributes_count = zero(UInt32))
PB.field_numbers(::Type{InstrumentationScope}) = (;name = 1, version = 2, attributes = 3, dropped_attributes_count = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:InstrumentationScope})
    name = ""
    version = ""
    attributes = PB.BufferedVector{KeyValue}()
    dropped_attributes_count = zero(UInt32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            version = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, attributes)
        elseif field_number == 4
            dropped_attributes_count = PB.decode(d, UInt32)
        else
            PB.skip(d, wire_type)
        end
    end
    return InstrumentationScope(name, version, attributes[], dropped_attributes_count)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::InstrumentationScope)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.version) && PB.encode(e, 2, x.version)
    !isempty(x.attributes) && PB.encode(e, 3, x.attributes)
    x.dropped_attributes_count != zero(UInt32) && PB.encode(e, 4, x.dropped_attributes_count)
    return position(e.io) - initpos
end
function PB._encoded_size(x::InstrumentationScope)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.version) && (encoded_size += PB._encoded_size(x.version, 2))
    !isempty(x.attributes) && (encoded_size += PB._encoded_size(x.attributes, 3))
    x.dropped_attributes_count != zero(UInt32) && (encoded_size += PB._encoded_size(x.dropped_attributes_count, 4))
    return encoded_size
end

struct KeyValueList{T1<:Union{Nothing,var"##AbstractKeyValue"}} <: var"##AbstractKeyValueList"
    values::Vector{T1}
end
PB.default_values(::Type{KeyValueList}) = (;values = Vector{KeyValue}())
PB.field_numbers(::Type{KeyValueList}) = (;values = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:KeyValueList})
    values = PB.BufferedVector{KeyValue}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, values)
        else
            PB.skip(d, wire_type)
        end
    end
    return KeyValueList(values[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::KeyValueList)
    initpos = position(e.io)
    !isempty(x.values) && PB.encode(e, 1, x.values)
    return position(e.io) - initpos
end
function PB._encoded_size(x::KeyValueList)
    encoded_size = 0
    !isempty(x.values) && (encoded_size += PB._encoded_size(x.values, 1))
    return encoded_size
end

struct AnyValue <: var"##AbstractAnyValue"
    value::Union{Nothing,OneOf{<:Union{String,Bool,Int64,Float64,var"##AbstractArrayValue",var"##AbstractKeyValueList",Vector{UInt8}}}}
end
PB.oneof_field_types(::Type{AnyValue}) = (;
    value = (;string_value=String, bool_value=Bool, int_value=Int64, double_value=Float64, array_value=ArrayValue, kvlist_value=KeyValueList, bytes_value=Vector{UInt8}),
)
PB.default_values(::Type{AnyValue}) = (;string_value = "", bool_value = false, int_value = zero(Int64), double_value = zero(Float64), array_value = nothing, kvlist_value = nothing, bytes_value = UInt8[])
PB.field_numbers(::Type{AnyValue}) = (;string_value = 1, bool_value = 2, int_value = 3, double_value = 4, array_value = 5, kvlist_value = 6, bytes_value = 7)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:AnyValue})
    value = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            value = OneOf(:string_value, PB.decode(d, String))
        elseif field_number == 2
            value = OneOf(:bool_value, PB.decode(d, Bool))
        elseif field_number == 3
            value = OneOf(:int_value, PB.decode(d, Int64))
        elseif field_number == 4
            value = OneOf(:double_value, PB.decode(d, Float64))
        elseif field_number == 5
            value = OneOf(:array_value, PB.decode(d, Ref{ArrayValue}))
        elseif field_number == 6
            value = OneOf(:kvlist_value, PB.decode(d, Ref{KeyValueList}))
        elseif field_number == 7
            value = OneOf(:bytes_value, PB.decode(d, Vector{UInt8}))
        else
            PB.skip(d, wire_type)
        end
    end
    return AnyValue(value)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::AnyValue)
    initpos = position(e.io)
    if isnothing(x.value);
    elseif x.value.name === :string_value
        PB.encode(e, 1, x.value[]::String)
    elseif x.value.name === :bool_value
        PB.encode(e, 2, x.value[]::Bool)
    elseif x.value.name === :int_value
        PB.encode(e, 3, x.value[]::Int64)
    elseif x.value.name === :double_value
        PB.encode(e, 4, x.value[]::Float64)
    elseif x.value.name === :array_value
        PB.encode(e, 5, x.value[]::ArrayValue)
    elseif x.value.name === :kvlist_value
        PB.encode(e, 6, x.value[]::KeyValueList)
    elseif x.value.name === :bytes_value
        PB.encode(e, 7, x.value[]::Vector{UInt8})
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::AnyValue)
    encoded_size = 0
    if isnothing(x.value);
    elseif x.value.name === :string_value
        encoded_size += PB._encoded_size(x.value[]::String, 1)
    elseif x.value.name === :bool_value
        encoded_size += PB._encoded_size(x.value[]::Bool, 2)
    elseif x.value.name === :int_value
        encoded_size += PB._encoded_size(x.value[]::Int64, 3)
    elseif x.value.name === :double_value
        encoded_size += PB._encoded_size(x.value[]::Float64, 4)
    elseif x.value.name === :array_value
        encoded_size += PB._encoded_size(x.value[]::ArrayValue, 5)
    elseif x.value.name === :kvlist_value
        encoded_size += PB._encoded_size(x.value[]::KeyValueList, 6)
    elseif x.value.name === :bytes_value
        encoded_size += PB._encoded_size(x.value[]::Vector{UInt8}, 7)
    end
    return encoded_size
end

struct KeyValue <: var"##AbstractKeyValue"
    key::String
    value::Union{Nothing,AnyValue}
end
PB.default_values(::Type{KeyValue}) = (;key = "", value = nothing)
PB.field_numbers(::Type{KeyValue}) = (;key = 1, value = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:KeyValue})
    key = ""
    value = Ref{Union{Nothing,AnyValue}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            key = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, value)
        else
            PB.skip(d, wire_type)
        end
    end
    return KeyValue(key, value[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::KeyValue)
    initpos = position(e.io)
    !isempty(x.key) && PB.encode(e, 1, x.key)
    !isnothing(x.value) && PB.encode(e, 2, x.value)
    return position(e.io) - initpos
end
function PB._encoded_size(x::KeyValue)
    encoded_size = 0
    !isempty(x.key) && (encoded_size += PB._encoded_size(x.key, 1))
    !isnothing(x.value) && (encoded_size += PB._encoded_size(x.value, 2))
    return encoded_size
end
